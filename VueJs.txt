				VUE JS - VUE 3
....................................................................................

Pre Knowldege:
1.HTML 5
2.CSS 3
3.Javascript ES 5 and ES 6 (Basic Features)
4.Node js Fundamentals - npm

Nice to Have
1.Angular 
2.React

Vue = Features of Angular + Features of React
.....................................................................................
What is Vue.js?
   Vue.js is a javascript framework for building user interfaces

What is User interface?
  The application where user interacts.

Types of user interface application:

1.Desktop applications
2.Web Applications which is running inside browser
3.Mobile Applications
   Native
   Browser based 
   Hybrid Mobile Application
4.Other devices based Apps

Web Applications:
.................
 The application is built and distributed over internet and accessed by using http protocal.

Types of web application:

Server side Web Application:
.............................

1.Static web apps - 1989 to 1995
https://home.cern/science/computing/where-web-was-born

2.Dynamic Content Generation Web App - 1996 to till date
  -CGI - C,Perl
  -J2EE - Java, Servlet
  -ASP - VbScript, vb
  -PHP - PHP
  -.net,nodejs,ruby..rails....
Output: HTML pages generated on fly.

3.Biz to Biz integration:
   Incase two biz organization want to share their information via internet
 DCG technology was not enough.
 Web Services:  1998 to till Date
  COMMON DATA Interchange format
   instead of exchanging html pages we can exchange data in the form of XML
  -XML - Soap Web Services
 2005 on wards - REST Full web services

,.............................................................................
Client side Web Apps:

Browser based :
 Desktop browsers
 Mobile browsers

 Powered with HTML With Javascript 
    Incase of dynamic web apps, html genereated by server and javascript changed and
 processed html pages at client side.


In 2007,W3c Introduced new web development arch, called "Single Page Web Application/SPA"

In SPA

 Client user interface applications were written using "HTML 5,CSS3,Javascript" where as server side applications are "Web Services-REST API" which serves data to the client.



SPA:
       Client User App (HTML,CSS,JS)<-------------------> REST API

SPA Frameworks:
1.Mustache.js
2.Angular.js
3.React
4.Angular
5.Vue.js
			.....................................................................................
			  Client Side Web Technology.

There are there primary languages 
1.HTML 5
2.Javascript 
3.CSS

DOM Programming:
...............

What is DOM?
  If you want to understand DOM, u need to undersand 

What is HTML? How it works?

HTML is the programming language,DSL / Declarative Programming language. Domain specific language- Domain specific language is nothing but the language built for sepcific domain, which cant be used for other purposes.

Since HTML is programming language, do you think that language is compiled?

C:
 hello.c -->compile --->hello.obj(compiled code)--->run compiled code by runtime.

Html:
 html code itself is compiled and executed - every thing happens within browser - In Memory compilation.

 index.html -->parsing---parsed code--->compilation--->binary code--->run compiled code by runtime-->final output in the screen.

index.html -  source code

<html>
 <head>
   <title>HTML</title>
 </head>
 <body>
     <h1>Welcome</h1>
 </body>
</html>
 --------------Browser
  |
 loader : load source code into browser
  |
  uses protocal 
   file or http
  |
  Parser : Parser is special compiler which converts source code into lexical tree
           (String tree)
   |

html
  head
   title
      HTML
   title
 head
 body
     h1
      Welcome
     h1
 body
html
   |
   compiler: Compilation: convert source code into assembly language
   |
html - LOAD XXX
  head-
   title
      HTML
   title
 head
 body
     h1
      Welcome
     h1
 body
html
.............................&&&&&&&&&&&&&..........................................  
                                Runtime

During runtime, we need to allocate memory for the program.

Runtime will create LinkedList(c) for the entire html document

html - Node
  head-
   title
      HTML
   title
 head
 body -Node
     h1  - Node
      Welcome
     h1
 body
html

Nodes are connected each other in Hierchical Structure(Tree)

Linking the Nodes (Tree)

body -Node
    |
     h1  - Node
      |
        Welcome
     h1
 body
 |
Layout Engine/Paint Engine
   |
  will convert into pxs - Final Ouput

            At End , the html page is "Tree Data Structure"

..........................***.....................................................
			The Netscap Communication and HTML Tree
.................................................................................
Netscap started a project,to access rendered "tree" via program.

Netcap initally decided to introduce c program,later who decided to change their mind to "Java".

Java was not also not suitable , the reason was , java was the big language , putting the language inside browser is not suitable.

Nets cap finally decided who did not want eiter c or java, but java like language
 - "The Birth of Javascript" 

The Javascript was introduced  as light weight programming language to access the tree,process the tree.

How to reprsent html inside javascript engine?
 
 Netscap took an idea "Object" Model.

Every html element is object, which is created once the browser loads the html into browser,and also object can be created using apis..

Javascript engins forms the tree called "Object Tree"


 index.html -->parsing---parsed code--->compilation--->binary code--->run compiled code by runtime-->final output in the screen --->Javascript Engine---creates  objects and forms object tree--->use api to process the tree...

.....................................................................................
			Netscap Objects and W3c
.....................................................................................

After Object tree model and javascript success, W3C  decided to standarize this arch/technology.

After standarization, w3c publish a spec called "DOM" -  Document Object Model


How dom works?

index.html           Broser runtime(C program)         Javascript Engine
<h1>Hello</h1>       h1-Node                           h1- Object
			Hello-Node			 Hello Object Property



                Every Html ELEMENT Inside Browser is "C Program"

	        Every Html ELEMENT Inside javascript engine is "Object"

HTML Elements(p,h1,div,img) are  represented inside browser as "Node", inside Javascript Engine "Object - DOM "


javascript developer ---->uses api --->to communicate Object---->js engine---->browser engine.
.....................................................................................
				DOM Programming
.....................................................................................

How to implement dom programming?

1.using plain js
  if we use plain js , it is very difficult to build large applications

2.using frameworks and libs

2000 - The first javascript framework - DOJO
2002-2005 - JQuery - is the second most powerfull dom lib.
After 2006 - many js libs and frameworks introduced.. 2008(Angular js) 2013(react)...

Popular DOM frameworks/lib:
1.React
2.Angular
3.Vue.js

           "Vue or React or Angular are just DOM abstractions"
....................................................................................
		      Vue js and Its Application types
...................................................................................

Vue.js is a framework used to build "different types of client side apps"


1.Standalone script application
   Enchancing html(genereated by server) by adding javascript /js lib(jquery)
 
if you have traditional web apps written using server side techn like jsp,asp,php which has "js/jquery" lib

    Vue is Declarative  replacement of Imperative "Jquery"


2.Web Component Application
    Vue supports to create web component arch based applications

3.Single Page Web Application(SPA)
   Vue is Primarily popuplar for building spa applications

4.Full Stack /SSR - Server side Rendered apps.
 
  SSR =  SPA + Server Side Technologies

 Pure SPA's has limitations when the app is sensitive to SEO and time to constent.
 Every thing happens in the browser side with respective SPA.

 Vue apps can be compiled/render in the server side.
 Server will generate html pages before sending to the browser(client) - Pre  rendering.
 https://nuxtjs.org/ -  for ssr with vuejs

5.SSG/JAMStack
   Server side static file generation(96), instead of build dynamic apps, suppose we need static apps.

  Server-side rendering can be done ahead of time if the required data is static. This means we can pre-render an entire application into HTML and serve them as static files.

 This improves site performance and makes deployment a lot simpler since we no longer need to dynamically render pages on each request. 

Vue can still hydrate such applications to provide rich interactivity on the client. This technique is commonly referred to as Static-Site Generation (SSG), also known as JAMStack.

The Vue team maintains a static-site generator called VitePress, which powers this website you are reading right now! In addition, Nuxt also supports SSG. You can even mix SSR and SSG for different routes in the same Nuxt app.
				
https://jamstack.org/

vue supported frameworks - VitePress,Nuxt



Beyond the Web:
...............

Although Vue is primarily designed for building web applications, it is by no means limited to just the browser. You can:

Build desktop apps with Electron or Tauri
Build mobile apps with Ionic Vue
Build desktop and mobile apps from the same codebase with Quasar
Use Vue's Custom Renderer API to build custom renderers targeting WebGL or even the terminal!

....................................................................................

App selections:

Whether your app is legacy server side apps built using j2ee or .net,php,rails--->
 Standalone vue.js

Your app is api centeric(webservices)/microservices
   Vue can be used as "SPA"

SPA With SSR for better optimization and SEO ready

SPA and SSR With SSG/JAM Stack - where your app is having static data
.....................................................................................
				Vue App Development
....................................................................................

Development work flows:

1.Without Build Tool
   Build tools like webpack,rollup,vitePress....
2.With Build Tool


Project Setup:
..............

1.without build tools

2.with build tools

1.without build tools:
   
You can create "Standalone Script apps".

Steps:

1.create Project

>mkdir vue-legacy

vue-legacy>mkdir src

vue-legacy>code .

create index.html outside src dir

index.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vue-legacy</title>
</head>
<body>
    
</body>
</html>

install live server in the vs code

open index.html using live server




in order to integrate vue with existing html

you have to add script which is distributed by vue community via "cdn".

There are two builds:
1.dev build
2.prod build

Dev Build

<script src="https://unpkg.com/vue@3"></script>

You are running a development build of Vue.
Make sure to use the production build (*.prod.js) when deploying for production.


Prod Build
 <script src="https://unpkg.com/vue@3.1.1/dist/vue.global.prod.js"></script>

....................................................................................
Core concepts of Vue
....................
			   Vue Application

Vue is just javascript framework, offers apis,infrastructure to build "DOM" programming.

DOM Programming:
1.create element or elements 
   When we create elements we create tree model-DOM tree
2.update existing elements content
3.remove/delete existing element content and element itself
4.list/walk through tree
5.we may change style dynamically
6.we interact with ui and change the ui.

Vue is javascript dom programming framework 

There are two ways of programming in UI:

1.imperative programming
    The way of write program using complex logics, more boiler plate code.
eg:
  create element using plain js
  create element using jQuery

 
<body>
    <h1>Imperative DOM- Create DOM Element using plain js </h1>
    <div id="root">

    </div>
    <script>
        function createElement() {
            console.log('init...')
            const Heading = document.createElement('h1');
            Heading.innerHTML = 'Hello,DOM'
            Heading.style.color = 'blue'
            document.getElementById('root').appendChild(Heading)
        }
        createElement()
    </script>

</body>


2.declarative programming

 =>write less code
 =>Abstract DOM apis with readable constructs 
 =>introduce declarative templates
Note:
 Template driven technology introduced in server side computing in 1990's
 2006, the first template driven technology was introduced in javascript called
 mustache.js ( {{}}})
 Template = static + dynamic  content , where dynamic content is interpolated into code. 
 eg <h1>Hello {{name}} </h1>

 "Vue is based on declarative , which extends standard HTML with a template syntax"
				+
			   java script => binds the state(data)/ biz logic

HTML + Extra Syntax + Bizlogic+data = Vue.js

How vue represents UI?

=>Vue creates UI dynamically(DOM)
=>Vue organizes the UI into smaller and smaller UI
=>VUE breaks the complex UI into Smallar UI
    This model is called called as "Compostion"

Why Compostion?
=>The UI can be reused any where in the app and also outside app.
=>The code maintaince is very easy,because it is independant.

	    "The arch is called as Component Driven Arch"

Component means parts of something.
.....................................................................................
			 Vue Instance /Application Object
.....................................................................................

In vuejs, the whole application(User interface), is composed into the object called
"Vue instance".

Vue Versions:

Vue 2.x
Vue 3.x

Vue Instance Creation:
......................
Vue 2
......

var app = new Vue({})

Vue 3:

We can get Vue instance:

 1.Via Global Vue Variable
 2.Via ES  6 Modules

			A.Via Global Vue variable
...................................................................................
Getting Vue instance:
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="https://unpkg.com/vue@3"></script>
</head>
<body>
    <h1>Vue Application Instance</h1>

    <script>
        const vueInstance = Vue 
        console.log(vueInstance)
        console.log(vueInstance.version)
    </script>
</body>
</html>
...................................................................................
....................................................................................
			B.Via Es 6 modules
.....................................................................................

can we use es 6 modules directly inside browser

name.js
export const name='Subramnaian'

index.js
import {name} from './name'


No, in older browsers
yes in modern browsers

Generally browser has no facility to link files and share code using "ES 6 modules keyword "

How to run es 6 module based apps inside browsers
Solution:
1.Using build tools - webpack,rollup.
   React,angular uses this tool behind it.

2.Using browser alone
   using type=module

 Recently browsers vendors added a capability to link files at browser level, this is still in experimental mode- many browsers(old browsers may not support)	

....................................................................................
			 ES 6 Modules and Browsers

src/name.js
export const name='Subramanian'
src/index.js
import {name} from './name.js'

console.log(name)

index.html

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vue</title>
    <script src="src/index.js" type="module"></script>
</head>
<body>
    <h1>ES 6 Modules</h1>    
</body>
</html>

Note:
 when you import you have to use "fileName.js"  eg : import {name} './name.js" 
 in script tag add type="module" attribute

.....................................................................................
			Can we use import statement inside html

can i import "src/name.js or src/index.js" inside script section of html.
2.Using browser alone
   Dynamically Import JavaScript with Import Maps

if you want import any js code within html file.

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>    
    <script type="importmap">
        {
          "imports": {
          
          }
        }
      </script> 
</head>
<body>    
    <!-- <script src="src/index.js" type="module"></script> -->

</body>
</html>


<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Es 6 modules</title>
    <!-- Polyfil for import map -->
    <script async src="https://ga.jspm.io/npm:es-module-shims@1.5.5/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
          "imports": {
            "name":"./src/name.js"
          }
        }
      </script>
</head>
<body>
    <h1>Using ES 6 Modules within HTML</h1>
    <script type="module">
        import { name } from 'name'
        console.log('name', name)
    </script>
</body>
</html>

Note:
Import Maps Browser Support

Import maps are supported by default in Chromium-based browsers, so we recommend using Chrome or Edge during the learning process.

If using Firefox, it is only supported in version 102+ and currently needs to be enabled via the dom.importMaps.enabled option in about:config.

If your preferred browser does not support import maps yet, you can polyfill it with es-module-shims.

    <script async src="https://ga.jspm.io/npm:es-module-shims@1.5.5/dist/es-module-shims.js"></script>

Not for production

The import-maps-based setup is meant for learning only - if you intend to use Vue without build tools in production, make sure to check out the Production Deployment Guide.

How to use vue using importMap syntax:
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Es 6 modules</title>
    <!-- Polyfil for import map -->
    <script async src="https://ga.jspm.io/npm:es-module-shims@1.5.5/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
          "imports": {
            "name":"./src/name.js",
            "vue" : "https://unpkg.com/vue@3/dist/vue.esm-browser.js"
          }
        }
      </script>
</head>

<body>
    <h1>Using ES 6 Modules within HTML</h1>
    <script type="module">
        import { name } from 'name'
        import { createApp } from 'vue'

        //calling createApp function,which returns "Vue Instance"
        const app = createApp()
        console.log(app)
        console.log(`version`,app.version)
        console.log('name', name)
    </script>
</body>

</html>
....................................................................................
			Vue is Root Instance having lot methods (factory methods)

createApp: (...args) => {…}
createBlock: ƒ createBlock(type, props, children, patchFlag, dynamicProps)
createCommentVNode: ƒ createCommentVNode(text = '', // when used as the v-else branch, the comment node must be created as a // block to ensure correct updates. asBlock = false)
createElementBlock: ƒ createElementBlock(type, props, children, patchFlag, 
etc...


Vue is component based framework, createApp method takes root/Entry component

function createApp(rootComponent: Component, rootProps?: object): App

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vue</title>
    <script async src="https://ga.jspm.io/npm:es-module-shims@1.5.5/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
          "imports": {
              "vue":"https://unpkg.com/vue@3/dist/vue.esm-browser.js"
          }
        }
      </script>
</head>

<body>
    <div id="root">

    </div>
    <script type="module">
        //step 1: import factory method
        import { createApp } from 'vue'

        //step 2 : create app instance and  pass root component
        const app = createApp({
            template: `<h1>Welcome to Vue Application</h1>`
        })
        console.log(app)
        //Step 3: mount root component into the root element
        app.mount('#root')

    </script>

</body>

</html>
.....................................................................................
			  User interface Development
.....................................................................................

User interface development guidelines:

1.User interface must be broken into smallar and smallar -  Compostion - Component model

2.User interface is organized in hierachal structure -  Tree Structure 
  Thats where html has been designed.
 We need to follow html tree model

 <div>
    <div>
	<div>
	   
	</div>
	
    </div>
 </div>

3.In tree model there must be one root element
..................................................................................
				Root Component(root Element)


In React:
 function Logo(){
   
   return <img src="logo.png"/>
 
}
In Angular

 @Component({
   selector:'app-logo'
   template:`<img src="logo.png"/>
 }) 
 export class Logo{

 }
In Vue:
 Component is object which is represented as literal object.

const Logo ={

}

What component contains:

 component information can be categorized into various segments.

const Logo ={
  template:''',
  render:'''
  compilerOptions:{},
  data:function(){}
}

1.UI/Rendering - HTML,CSS(Markup)
..................................
 template
 render
 compilerOptions

2.State -(data) - javascript
 data 
 props
 computed
 methods
 watch
 emits
 expose

3.Life Cycle hooks(methods)
beforeCreate
created
beforeMount
mounted
beforeUpdate
updated
beforeUnmount
unmounted
errorCaptured
renderTracked
renderTriggered
activated
deactivated
serverPrefetch

4.Composition
 provide
 inject
 mixins
 extends

Misc
name
inheritAttrs
components
directives

Component Instance api and variables
$data
$props
$el
$options
$parent
$root
$slots
$refs
$attrs
$watch()
$emit()
$forceUpdate()
$nextTick()


const Logo ={
  ui: {},
  state:{}
  others:{}
  methods:{} 
}
.....................................................................................
			Vue Application Setup using Build Tools
....................................................................................

Build tools are js based tools for create,manage js apps work flows.
Build tools based on npm tool.


Setup Vue Project using build tool based: CLI based apporach.
.............................................................

There are two cli tools

1.Vue-cli
  https://cli.vuejs.org/#getting-started
Vue- cli is now in maintance mode, meaning that , which is only used for creating old vue project(v2)

2.Vite
https://vitejs.dev/guide/
Next Generation Frontend Tooling project, used to create no of project types.

We are going to follow Vite base project setup

npm init vue@latest

This is abstraction for vite based project templates

npm init vue@latest
Need to install the following packages:
  create-vue@3.7.1
Ok to proceed? (y) y

Vue.js - The Progressive JavaScript Framework

√ Project name: ... vue-app
√ Add TypeScript? ... No / Yes
√ Add JSX Support? ... No / Yes
√ Add Vue Router for Single Page Application development? ... No / Yes
√ Add Pinia for state management? ... No / Yes
√ Add Vitest for Unit Testing? ... No / Yes
√ Add an End-to-End Testing Solution? » No
√ Add ESLint for code quality? ... No / Yes

Scaffolding project in E:\session\IBM\2023\July\VueJs\vue-app...

Done. Now run:

  cd vue-app
  npm install
  npm run dev

Folders and file structure:

package.json
{
  "name": "vue-app",
  "version": "0.0.0",
  "private": true,
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "vue": "^3.3.4"
  },
  "devDependencies": {
    "@vitejs/plugin-vue": "^4.2.3",
    "vite": "^4.3.9"
  }
}

vite.config.js
 It is build tool for vue apps

import { fileURLToPath, URL } from 'node:url'
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [
    vue(),
  ],
  resolve: {
    alias: {
      '@': fileURLToPath(new URL('./src', import.meta.url))
    }
  }
})

index.html
  It is entry file which initalizes the initial DOM and vue app

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <link rel="icon" href="/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vite App</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.js"></script>
  </body>
</html>
....................................................................................
				Vue coding style
....................................................................................
Vue coding can be classified into two category

Vue 2.X and Vue 3.X

Api classification:
...................

1.Options Api Based Style - Vue 2.x Style and Vue 3.x
2.Composition Api Based Style  -Vue 3.x Style

.....................................................................................
			 Components Creational Patterns
....................................................................................

1.Plain Java script Pattern

App.js
export default {
  
  ...options 
  
}

It is more imperative way of creating components

2.Single File Components -SFC

 It is more declarative way of creating components
 As name suggest, All Component logic inside single file.


Plain Javascript pattern is used inside "Standalone script application" - without build tool

SFC pattern is used inside "build work flow"


How to create component without build tool.

eg: Plain JS pattern
src/components/App.js
//Component creation based on js extension: without build tool 
export default {
    template: `
             <h1>Vue Application!</h1>
            `,
    //rest of the apis

}

index.html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <!-- Polyfil lib for importmap -->
    <script async src="https://ga.jspm.io/npm:es-module-shims@1.5.5/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
          "imports": {
              "vue":"https://unpkg.com/vue@3/dist/vue.esm-browser.js",
              "app": "./src/components/App.js"
          }
        }
      </script>
</head>

<body>

    <div id="root">
        <!-- Insert dom node -->
    </div>
    <script type="module">
        //step 1: import factory method
        import { createApp } from 'vue'
        import  Application  from 'app'
        //step 2: create app instance
        // const app = createApp({
        //     template: `<h1> Welcome to Vue Application</h1>`
        // })
        const app = createApp(Application)
        //Step 3: Mount the component into root element
        app.mount("#root")

    </script>
</body>

</html>

Plain javascript pattern is usefull where there is no build workflow,SFC is usefull and necessary in build tool work flow 

		  SFC components are saved with fileName.vue
		Plain javascript pattern files are saved with fileName.js

.....................................................................................
			    SFC 

Components have three major segment:

1.template 
   collection of html elements and vue instructions
2.javascript
   collection of variables,methods
3.style 
   css style for a component


In SFC Pattern, we isloate very clearly into three sections

SFC files are saved "fileName.vue" extension

<script>
   ....All javascript code
</script>
<template>
  ...template code
</template>
<style>
 //style for this component
</style>

Single File Component Pattern -SFC
App.vue

<!-- Three segments -->
<script>
</script>
<template>
    <h1>Hello Vue!</h1>
</template>
<style>
</style>

	      "Going forward we focus only SFC pattern"

Inside SFC , we can use either Options Api Based Style or Composition Api Based Style 

....................................................................................
			Commonality between both patterns
 			(Options api and Composition api)

1.code segementation is same
  <script></script>
  <template></template>
  <style></style>

Options Api Pattern:
......................
In options Api Pattern, we return Options Object , which contains neccessary configurations.

<script>
 //return options object
 export default {
    //options

 }
<script>


eg:

<!-- Options Api Pattern -->
<script>
//you have to return Options Object
export default {
    props:['something'],
    data() {
        return {
            name: 'Subramanian'
        }
    }
}
</script>
<template>
    <h1>Components Using Options Api Pattern</h1>
</template>
<style>

</style>
....................................................................................
			  Composition Api Pattern

In this pattern we define a component logic's using imported Api functions
In this pattern we write code directly inside script.

		          Composition Api Pattern
				  |
		----------------------------------------------------
		|                                                  |
	      with setup function                          with setup attribute	

With Setup function:
...................
1.Looks like Options api pattern but code refactoring done.
2.It looks like imperative style of compostion apis.

<!-- Compsition pattern with setup function -->
<script>
export default {
    setup() {
        //all js initalization code will go here
    }
}
</script>
<template>
</template>
<style>

</style>

With setup attribute:
....................

1.vue compiler writes all boiler plate code for us.

<!-- Compsition pattern with setup attribute -->
<script setup>
// you can write app logic directly : which looks like regular js code
</script>
<template>
    <h1>Single File Component with Composition api with setup attribute</h1>
</template>
<style>

</style>


 				Vue App
				   |
			---------------------------------------  
			With Build tool                  without build tool
				 |				|
			SFC Component            	 Script based (refer above)
				   |
	----------------------------------------------------------------
        |                                                             |
        |                                                             |

      Options Api                                              Composition Api
	 |                                                          |
   Vue 2 based apps                                           Vue 3 based apps
							        												|	
		  							|
				----------------------------------------------------
				|                                       |
	      	with setup function                           with setup attribute	

....................................................................................

Component with Options api:
...........................
<!-- Options api pattern -->
<script>
// Options Object : we have to return always options Object
export default {
   //js logic goes
}
</script>
<template>
 <h1>Options Api Demo</h1>
</template>
<style>

</style>

Component with compostion api : with setup function
<script>
export default {
    setup() {

    }
}
</script>
<template>
    <h1>Composition api with setup function</h1>
</template>
<style>

</style>

Composition with setup attribute:
<script setup>

</script>
<template>
    <h1>Composition api with setup Attribute</h1>
</template>
<style>

</style>
...................................................................................
				Composition
..................................................................................
Organization of Components in hierachical order(tree) pattern

<div id="root">
    <App>
	<Hello></Hello>
    </App>
</div>

eg:

Component with "Options API"
 
In this pattern, component must be registered inside script
using components key

src/components/greeter/Hello.vue
<script>
</script>
<template>
    <h2>Hello</h2>  
</template>
<style>
</style>

src/components/greeter/App.vue
<script>
import Hello from "./components/greeter/Hello.vue";

export default {
    components: { Hello }
}
</script>
<template>
    <div>
        <h1>App</h1>
        <Hello></Hello>
    </div>
</template>
<style>

</style>

Component with "Composition  API with setup function"
......................................................

src/components/Message.vue
<!-- composition  api pattern : using setup function -->
<script>
export default {
    setup() {

    }
}
</script>
<template>
    <h1>Hello</h1>
</template>
<style></style> 

src/components/Hello.vue

<script>
import Message from './Message.vue';

export default {
    components: { Message },
    setup() {

    }
}
</script>
<template>
    <Message></Message>
</template>
<style></style>

src/App.vue
<script>
// import components
import Hello from './components/greeter/Hello.vue';

export default {
    components: {
        Hello
    },
    setup(){
        
    }
}
</script>
<template>
    <Hello></Hello>
</template>
<style></style>

Component with "Composition  API with setup attribute"
......................................................

src/components/Message.vue
<script setup>
</script>
<template>
    <h1>Hello</h1>
</template>
<style></style> 


src/components/Hello.vue

<!-- Composition api : using setup attribute -->
<script setup>
import Message from './Message.vue';
</script>
<template>
    <Message></Message>
</template>
<style></style>


src/App.vue
<!-- Composition api pattern : using setup attribute-->
<script setup>
import Hello from './components/greeter/Hello.vue';
</script>
<template>
    <Hello></Hello>
</template>
<style></style>
.....................................................................................


Assigment-1:
............
Create Layout Components

1.header
   |
   Logo
   SearchPanel
   LoginPanel
2.main
   |
   three sections
    -Vue features
3.Footer
   |
   Sponors
   copyright

You have to try

1.Options api
2.Compositions api with imperative (setup fun) and declarative Patterns (setup attr)
		 
............................&&&&&&&&&&..............................................
			 Component Registeration -Creations
.....................................................................................

A Vue component needs to be "registered" so that Vue knows where to locate its implmeneation when it is encountered in a template.


Two Types of Registeration:

1.Global Registeration
  Global Components
2.Local Registeration
  Local Components

Global Components:
  Components are created and  registered as part of the application object
  Global Components can be accessed any where in the application without explicit   configuration

Application object having lot of methods
app.component()
app.use()
app.provide()
etc...
https://vuejs.org/api/application.html#app-component


mport { createApp } from 'vue'

const app = createApp({})

// register an options object
app.component('my-component', {
  /* ... */
})

// retrieve a registered component
const MyComponent = app.component('my-component')

.....................................................................................
eg:
src/components/StatusBar.vue
<script setup>
</script>
<template>
    <h2>Status Bar!!</h2>
</template>
<style>
</style>

src/main.js

import { createApp } from 'vue'
import App from './App.vue'
import StatusBar from './components/global/StatusBar.vue'
import './assets/main.css'
// console.log(App)

const app = createApp(App)

app.component('StatusBar', StatusBar)


app.mount('#app')

src/App.vue
<script>
import StatusBar from './components/global/StatusBar.vue';
export default {
    //components: { StatusBar }
}

</script>
<template>
    <StatusBar></StatusBar>
</template>
<style>
</style>

Without import also global components works:

<!-- Compostion api pattern using setup attribute -->
<script>
import Hello from './components/greeter/Hello.vue'
// import StatusBar from './components/global/StatusBar.vue'

export default {
    components: { Hello }
}
</script>
<template>
    <Hello></Hello>
    <StatusBar></StatusBar>
</template>



Short cut inside main.js
import { createApp } from 'vue'
import App from './App.vue'
import StatusBar from './components/global/StatusBar.vue'
import './assets/main.css'
// console.log(App)
// const app = createApp(App)
// app.component('StatusBar', StatusBar)
// app.mount('#app')

createApp(App)
    .component('StatusBar', StatusBar)
    .mount('#app')

Note:
 Here incase the component is part of application object(Global Component), we need not register with components using {components:CompName}
....................................................................................

			 Local Components Registration
................................................................................

Components are registered when the child component is created

SFC using composition pattern using setup attribute:

Greeter.vue
<script setup>
  import ComponentA from './ComponentA.vue'
</script>

<template>
  <ComponentA />
</template>

SFC using composition pattern using without setup attribute:

Greeter.vue
<script setup>
  import ComponentA from './ComponentA.vue'

export default {
   components: { 
         ComponentsA
   }
}
</script>

<template>
  <ComponentA />
</template>

..................................................................................
			Both local and global compoents
...................................................................................
<script>
import StatusBar from './components/global/StatusBar.vue';
import Hello from './components/greeter/Hello.vue';
export default {
    components: { Hello } //Local Component Registration,we tell to the vue engine that when ever you encounter this , create instance for this component.
}
</script>
<template>
    <StatusBar></StatusBar>
    <Hello></Hello>
</template>
<style>
</style>
,,,,,,,,,,,,,,,,,,,,..................,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
...................................................................................
			Global Vs Local Component Registration
.................................................................................
=>Global registration prevents build systems from removing unused components (a.k.a "tree-shaking").
=>If you globally register a component but end up not using it anywhere in your app, it will still be included in the final bundle.

=>Global registration makes dependency relationships less explicit in large applications. 

=>It makes it difficult to locate a child component's implementation from a parent component using it.

=>This can affect long-term maintainability similar to using too many global variables.

=>Global Components need to be imported inside any where

<script>
// import StatusBar from './components/global/StatusBar.vue';
import Hello from './components/greeter/Hello.vue';
export default {
    components: { Hello } //Local Component Registration,we tell to the vue engine that when ever you encounter this , create instance for this component.
}
</script>
<template>
    <StatusBar></StatusBar>
    <Hello></Hello>
</template>
<style>
</style>
.....................................................................................
....................................................................................
....................................................................................
			 Component Naming Conventions
.....................................................................................

PascalCase names are valid JavaScript identifiers. This makes it easier to import and register components in JavaScript. It also helps IDEs with auto-completion.

<PascalCase /> makes it more obvious that this is a Vue component instead of a native HTML element in templates. It also differentiates Vue components from custom elements (web components).


This is the recommended style when working with SFC or string templates. However, as discussed in DOM Template Parsing Caveats, PascalCase tags are not usable in DOM templates.

The Component names can be kebab-case /dash case eg
   <app-root>
   <hello-world>
   <greeter>

	Vue supports both cases , but highly recommened is Pascal Case

App.vue

<script setup>
import Hello from './components/greeter/Hello.vue';
</script>
<template>
    <!-- Pascal case -->
    <StatusBar></StatusBar>
    <Hello></Hello>
    <!-- dash-case/Kebab-case -->
    <status-bar></status-bar>
    <hello></hello>
</template>
<style></style>
.....................................................................................
				Vue dev tool
.....................................................................................

https://devtools.vuejs.org/guide/installation.html
.....................................................................................
.....................................................................................
			    Templates
...................................................................................
Template is the representation of View
View is Runtime representation

Template can be static or dynamic 

Static templates are having pure html code
Dynamic templates are having html code + Vue instructions
Vue instructions are special symbols
  
Template  = html + vue instructions (data,events,props)

Data Binding:
.............
  Passing data from the Component to View and View to Component

Types of Data bidning:

1.interpolation
2.property /props binding
3.attribute binding
4.event binding
5.Two way data binding
6.class and style binding
.....................................................................................
.....................................................................................
			  MVC  Architecture
....................................................................................

In order to build user interface we have architectures

1.MVC 
  It is the most legacy arch but still more popular arch, used in server side,client   side app developments

2.Flex 
   It is discovered by face book, in order to replace MVC , primarily used in React..

Vue js is MVC Based  and Flex mixed arch -hybrid arch..

M - Model - State - Data
V - View  - User interface
C - Controller - Having data and biz logic

Vue and MVC:
<script>
   // M + C ->logic
</script>
<template> 
   View logic 
</template>
<style>
</style>

 Component = {Model+Controller(Script) ,View(template,style)}

...................................................................................
				Interpolation
....................................................................................

Transfering data(state) from (controlller) to View.

State:
  State Can be represented in two ways

1.primitives - numbers,strings,boolean
  let name='subramanian'
  let salary=100
  let isValid=true
2.objects and collections -  literal object,arrays
  
  let profile = {
    id:1,
    name:'Arun'
  }
  let profiles = [{
    id:1,
    name:'Arun'
  },{
    id:2,
    name:'Bala'
  }]
SFC:
 1.Using Options api
 2.Using Composition api
    -with setup fun
    -with setup attribute

1.Using Options Api
    Encapsulate options inside literal object

let options = {
  data:?
  props:?
  methods:?
}

State Declaration and Options Api:
.................................

Syntax:
<script>
export default {
   data:function(){
	return {
           data:....
	} //state object 
   }
}
</script>

data is function which encapulsates state(Model)
data function must return object which encapuslate "state/model".

Syntax: es 6 way of declaration function
<script>
export default {
   data(){
	return {
           data:....
	} //state object 
   }
}
</script>


Eg:
<!-- State Declaration : Using Options api -->
<script>
export default {
    data() {
        return {
            name: 'Subramanian' //state
        }
    }
}
</script>
<template>
    <div>
        <h1>State Declaration and InterPolation Using Options Api</h1>

    </div>
</template>
<style></style>

How to show the state inside view (template)?

Via Data binding - interpolation {{variable}}


Eg:
State with Options Api:
<!-- State Declaration : Using Options api -->
<script>
export default {
    data() {
        return {
            firstName: 'Subramanian',
            lastName: 'Murugan',
            address: {
                city: 'Coimbatore',
                state: 'Tamil Nadu'
            },
            points: 120,
            status: true
        }
    }
}
</script>
<template>
    <div>
        <h1>State Declaration and InterPolation Using Options Api</h1>
        <div>
            <h2>Name {{ firstName }} {{ lastName }}</h2>
            <h2>Address {{ address.city }} {{ address.state }}</h2>
            <h3>Points  {{ points }}</h3>
            <h3>Status {{ status ? "Available" : "Not Available" }}</h3>
        </div>
    </div>
</template>
<style></style>
...................................................................................
			   Composition Api - Using Setup function

The component logic must be encapsulated inside a function called "setup"

export default {

 setup(){

   return {} //must return state
 }

}

eg:
<!-- State Declaration : Using Compostion api-setup function -->
<script>
export default {
    setup() {
        const firstName = 'Subramanian'
        const lastName = 'Murugan'
        const address = {
            city: 'Coimbatore',
            state: 'Tamil Nadu'
        }
        const points = 120
        const status = true

        //return object 
        return {
            firstName,
            lastName,
            address,
            points,
            status
        }

    }
}
</script>
<template>
    <div>
        <h1>State Declaration and InterPolation Using Options Api</h1>
        <div>
            <h2>Name {{ firstName }} {{ lastName }}</h2>
            <h2>Address {{ address.city }} {{ address.state }}</h2>
            <h3>Points {{ points }}</h3>
            <h3>Status {{ status ? "Available" : "Not Available" }}</h3>
        </div>
    </div>
</template>
<style></style>

...................................................................................
			   Composition Api - Using Setup attribute

<!-- State Declaration : Using Compostion api-setup attribute -->
<script setup>
const firstName = 'Subramanian'
const lastName = 'Murugan'
const address = {
    city: 'Coimbatore',
    state: 'Tamil Nadu'
}
const points = 120
const status = true
</script>
<template>
    <div>
        <h1>State Declaration and InterPolation Using Options Api</h1>
        <div>
            <h2>Name {{ firstName }} {{ lastName }}</h2>
            <h2>Address {{ address.city }} {{ address.state }}</h2>
            <h3>Points {{ points }}</h3>
            <h3>Status {{ status ? "Available" : "Not Available" }}</h3>
        </div>
    </div>
</template>
<style></style>
.....................................................................................
				Directives
....................................................................................

What is directive?
  Directive is object which helps to create custom elements and attributes.
  Directives enchances existing html elements - We extend the functionality of HTML   elements.
  We are going to add new behaviour to the HTML elements.

Vue is highly modular framework, code Resue is Main Objective.


Code Resue Patterns:
...................
1.Components
2.Composables(Hooks)
3.Directives


Components are main building blocks.
Composable are focused on "Resuing stateful logic" - Data isloation.
Directives are mainly intented for resuing logic that involes low level DOM Access on Plain Elements -DOM Element features.

HTML elements Types:

1.Built in element and attributes
2.Custom elements and attributes

<h1>Hello</h1> -  built in element.

HTML Compiler Work flow:
.......................


<h1>Hello</h1> -----Compiler verfies this element is built in or not
				|
		   --------------------------------
		   |                              |
                 Yes                             No
		  |                              |
Browser parses the                    Browser throws exception                       called                                "UnknownElement"
element and convert                   which is converted into plain ascii node
it , render accordingly


 <app-root>  -----Compiler verfies this element is built in or not
				|
		   --------------------------------
		   |                              |
                 Yes                             No
		  |                              |
Browser parses the                    Browser throws exception                       called                                "UnknownElement"
element and convert                   which is converted into plain ascii node
it , render accordingly


<app-drawer> - it is custom element, generally browser does not under stand.

In 2007, W3c introduced new idea that developers can add their own tags/elements(custom elements and custom attributes)
   HTML 5 Specification

built in element logic is already written, so that browser easily understands that.

What about custom element, how to teach browser to understand custom elements?
    
  "Through Javascript"

<app-drawer> ---|JS Code--->Runs ---renders in the browser....

eg:
<script setup>
import AppDrawer from './components/drawer/AppDrawer.vue'
</script>
<template>
<h1>Drawer App</h1>
<!-- Custom element -->
<app-drawer></app-drawer>
</template>
<style>

</style>

src/componnets/drawer/AppDrawer.vue
<script setup>
</script>
<template>
    <p>Drawer Element</p>
</template>
<style>
</style>

 		"Every Component is a Custom element only"

.....................................................................................
			Custom Attributes
.....................................................................................

1.Built in element Attributes

 <img src="" alt="">
       |      |
   Attributes - Built in attributes

Browser knows how to put logic to src and alt.

2.Custom attributes on existing html elements

<img customAttribute />
        | 
     custom attribute
How to teach browser to parse custom Attributes 
  "Through Javascript"

eg: Vue rendered page:

<div id="app" data-v-app="">
<h1>Drawer App</h1>
 <!-- Custom element --><p>Drawer Element</p>
</div>
.....................................................................................
	Vue.js Helps to add Custom attributes on existing elements via "Directives" -				Attribute Directives
.....................................................................................
Vue js attribute directive syntax:

v-directiveName

Built in Directives:
...................
v-text
v-html
v-show
v-if
v-else
v-else-if
v-for
v-on
v-bind
v-model
v-slot
v-pre
v-once
v-memo
v-cloak

Special Attributes
key
ref
is
.....................................................................................
			    v-html and v-text
...................................................................................

v-html :
 inserts data into html element as "HTML"  - innerHTML 
{{}} 
  inserts data into html element as "Plain Text"

				v-text

Update the element's text content. - innerText

<script setup>
//variable
const name = 'Subramanian'
</script>
<template>
    <h1>Interpolation using mustace notation</h1>
    <h2>Name {{name}}</h2>
    <h1>Interpolation using using Directives-text </h1>
    <h2 v-text="`name ${name}`"></h2>
    <h1>Interpolation using using Directives-html </h1>
    <h2 v-html="`name ${name}`"></h2>
</template>
<style>

</style>
...................................................................................
			 v-bind
...................................................................................

V-binds html attributes values or components values(properties) dynamically.

Binding: Attach value to the attribute

Static Binding
  <img src="logo.png"/>
	|         |
       attribute  attributevalue
here value of src cant be changed once the ui rendered

<script setup>
const imageUrl = "/src/assets/logo.svg"
const isEnabled = true
const isHidden = false
</script>
<template>
    <div>
        <h1>Bind Directives</h1>
        <div>
            <h1>Static Binding</h1>
            <img src="./assets/logo.svg" height="100" width="100" />
        </div>
        <div>
            <h1>Dynamic Binding with v-bind</h1>
            <img v-bind:src="imageUrl" height="100" width="100"/>
        </div>
        <div>
            <h1>Dynamic Binding with v-bind with short cut</h1>
            <img :src="imageUrl" height="100" width="100"/>
        </div>
        <div>
            <h1>Dynamic Binding with v-bind Button enabled</h1>
            <button :disabled="isEnabled">Click</button>
        </div>
        <div>
            <h1>Dynamic Binding with v-bind Article hidden</h1>
            <article :hidden="isHidden">
                <p>This is vue article</p>
            </article>
        </div>
    </div>
</template>
<style></style>
.....................................................................................
				Props
.....................................................................................
.....................................................................................
			Component Driven Design principles
.....................................................................................

Role of Components / Responsibility of Component:
..................................................

Component having state,bizlogic,ui

As per component design design principles , we need to apply modularity concept.
  Break the component based on two aspects

1.Having data and biz logic
    -Parent Component /Container component
2.Having UI logic
    -Child Component/Presentational Component


Data(State) Sharing Patterns/ Data(State) Representation Patterns:
....................................................

1.Props Pattern
  The data is shared from the Parent Component to Child Component.
2.State Pattern
  The data is reprensented with in component and mutate it.   

From Parent Component template:

   <ProductDetails title="Product Details" ></ProductDetails>
                     |            |
                  PropertyName   Property value
   <div id="">
	 |
       attribute

How to structure a Large scale vue.js app

Default strcture

src
  |
  components
    |
    User 
    Product
    Comments
    Payment

Standard Structure of apps would be domain model

src
  |
  components
    |
    User 
      Userlist.vue
      UserDetails.vue
      User.vue
   Product	
      ProductList.vue
      ProductDetails.vue
      Product.vue
   stores
   layouts
   plugins
   directives
   helpers/utils
....................................................................................
			 Props - Pattern implementation
.....................................................................................

How to pass data from parent component to child component?

since we have many coding pattern (options api, composition api).

Props with Options api:
.......................

src/components/ProductMaster.vue
<script>
import ProductDetails from './ProductDetails.vue'
export default {
    components: {
        ProductDetails
    }
}
</script>
<template>
    <div>
        <h1>Product Master</h1>
        <!-- title is prop -->
        <ProductDetails title="Product Page" />
    </div>
</template>


src/components/ProductDetails.vue
<script>
export default {
    props: ['title']
}
</script>
<template>
    <div>
        <h1>{{title}}</h1>
    </div>
</template>

src/App.vue
<script>
import ProductMaster from './components/products/ProductMaster.vue'

export default {
    components: { ProductMaster }
}
</script>
<template>
    <div>
        <h1>App</h1>
        <ProductMaster></ProductMaster>
    </div>
</template>

How to pass data to component as prop:


src/components/ProductMaster.vue
<script>
import ProductDetails from './ProductDetails.vue'
export default {
    components: {
        ProductDetails
    },
    data() {
        return {
            product: {
                id: 1,
                name: 'Phone',
                qty: 100,
                price: 1000,
                inStock: 'true'
            }
        }
    }
}
</script>
<template>
    <div>
        <h1>Product Master</h1>
        <!-- title and product  are prop : title is static prop product is dynamic prop -->
        <ProductDetails title="Product Page-1" :product="product" />
        <ProductDetails title="Product Page-2" :product="product" />
        <ProductDetails title="Product Page-3" :product="product" />
        <ProductDetails title="Product Page-4" :product="product" />
        <ProductDetails title="Product Page-5" :product="product" />

    </div>
</template>


src/components/ProductDetails.vue
<script>
export default {
    props: ['title','product']
}
</script>
<template>
    <div>
        <h1>{{title}}</h1>
        <h2>Id {{product.id}}</h2>
        <h2>Name {{product.name}}</h2>
        <h2>Price {{product.price}}</h2>
        <h2>Qty {{product.qty}}</h2>
        <h2>Stock {{product.inStock ? "Available" : "Not Available"}}</h2>


    </div>
</template>


src/App.vue
<script>
import ProductMaster from './components/products/ProductMaster.vue'

export default {
    components: { ProductMaster }
}
</script>
<template>
    <div>
        <h1>App</h1>
        <ProductMaster></ProductMaster>
    </div>
</template>
....................................................................................
			 Props Composition api : Using setup function
.....................................................................................


src/components/products/ProductDetails.vue

<!-- composition api with setup function -->
<script>
export default {
    props: ['title', 'product'],
    setup() {

    }
}
</script>
<template>
    <div>
        <h1>{{ title }}</h1>
        <h2>Id {{ product.id }}</h2>
        <h2>Name {{ product.name }}</h2>
        <h2>Price {{ product.price }}</h2>
        <h2>Qty {{ product.qty }}</h2>
        <h2>Stock {{ product.inStock ? "Available" : "Not Available" }}</h2>
    </div>
</template>

src/components/products/ProductMaster.vue

<!-- Props with composition api with setup function -->
<script>
import ProductDetails from './ProductDetails.vue'

export default {
    components: {
        ProductDetails
    },
    setup() {
        
        return {
            product: {
                id: 1,
                name: 'Phone',
                qty: 100,
                price: 1000,
                inStock: 'true'
            }
        }
    }
}
</script>
<template>
    <div>
        <h1>Product Master</h1>
        <!-- title and product  are prop : title is static prop product is dynamic prop -->
        <ProductDetails title="Product Page-1" :product="product" />
        <ProductDetails title="Product Page-2" :product="product" />
        <ProductDetails title="Product Page-3" :product="product" />
        <ProductDetails title="Product Page-4" :product="product" />
        <ProductDetails title="Product Page-5" :product="product" />

    </div>
</template>


src/App.vue
<script>
import ProductMaster from './components/products/ProductMaster.vue'

export default {
    components: { ProductMaster },
    setup() {

    }
}
</script>
<template>
    <div>
        <h1>App</h1>
        <ProductMaster></ProductMaster>
    </div>
</template>
////////////////////////////////////////////////////////////////////////////////////
....................................................................................
			 Props Composition api : Using setup attribute
.....................................................................................


src/App.vue
<!-- Composition api with setup attribute -->
<script setup>
import ProductMaster from './components/products/ProductMaster.vue'
</script>
<template>
    <div>
        <h1>App</h1>
        <ProductMaster></ProductMaster>
    </div>
</template>


src/components/products/ProductMaster.vue
<script setup>
import ProductDetails from './ProductDetails.vue'
const product = {
    id: 1,
    name: 'Phone',
    qty: 100,
    price: 1000,
    inStock: 'true'
}

</script>
<template>
    <div>
        <h1>Product Master</h1>
        <!-- title and product  are prop : title is static prop product is dynamic prop -->
        <ProductDetails title="Product Page-1" :product="product" />
        <ProductDetails title="Product Page-2" :product="product" />
        <ProductDetails title="Product Page-3" :product="product" />
        <ProductDetails title="Product Page-4" :product="product" />
        <ProductDetails title="Product Page-5" :product="product" />

    </div>
</template>

src/components/products/ProductDetails.vue

In setup attribute, vue provides global api called "defineProps" method.


<script setup>
const props = defineProps(['title', 'product'])
console.log(props)
</script>
<template>
    <div>
        <h1>{{ props.title }}</h1>
        <h2>Id {{ props.product.id }}</h2>
        <h2>Name {{ product.name }}</h2>
        <h2>Price {{ product.price }}</h2>
        <h2>Qty {{ product.qty }}</h2>
        <h2>Stock {{ product.inStock ? "Available" : "Not Available" }}</h2>
    </div>
</template>
....................................................................................
		How to access Props inside script(Composition api)
..................................................................................

setup function:
 props are passed as arg to the setup function.
<script>
export default {
    props: ['title', 'product'],
    setup(props) {
        console.log(props.product)
    }
}
</script> 
<template>
    <div>
        <h1>{{ title }}</h1>
        <h2>Id {{ product.id }}</h2>
        <h2>Name {{ product.name }}</h2>
        <h2>Price {{ product.price }}</h2>
        <h2>Qty {{ product.qty }}</h2>
        <h2>Stock {{ product.inStock ? "Available" : "Not Available" }}</h2>
    </div>
</template>

Inside Setup attribute:

<script setup>
const props = defineProps(['title', 'product'])
console.log(props.title,props.product)
</script>
<template>
    <div>
        <h1>{{ title }}</h1>
        <h2>Id {{ product.id }}</h2>
        <h2>Name {{ product.name }}</h2>
        <h2>Price {{ product.price }}</h2>
        <h2>Qty {{ product.qty }}</h2>
        <h2>Stock {{ product.inStock ? "Available" : "Not Available" }}</h2>
    </div>
</template>
...................................................................................
			 Property Validation
...................................................................................
Some times i want to enforce the property data type validation, which is only for runtime vertification.

eg:
 i have property called age
 i need to define rule for age that age must be number,it should not be string.

defineProps Syntax:
1.simple Syntax

  defineProps(['propName','propName'])

2.Complex Syntax : prop validation rule, default value 

  defineProps({
     age:Number,  
     id: [Number,String] // can be string or can be number
     name: {
      type:String
      required:true,
      default:'name'
     },
     address: {
	type:Object,
        default(rawProps){
	    return {
		city:'mycity'
            }
        }
     },
    status: {
	validator(value){
	  return ['OK','NotOk','Success','Failure'].includes(value)
       }
    }
 })

Runtime Types:
1.String
2.Number
3.Boolean
4.Array
5.Object
6.Date
7.Function
8.Symbol

eg:

src/App.vue
<script setup>
import User from './components/profile/User.vue';
// const name = "Subramanian" 
const name = 122323
const disabled = true
</script>
<template>
    <User :name="name" :disabled="disabled"></User>
    <!-- Boolean :Boolean has special casting rules to mimic the behavior of the native boolean elements -->
    <User disabled></User>
    <User></User>

</template>
<style></style>

src/components/profile/User.vue
<script setup>
const props = defineProps({
    name: {
        type: String,
        default: 'Name is Missing'
    },
    disabled: {
        type:Boolean,
        default:false 
    }

})
</script>
<template>
    <div>
        <h1>User Page</h1>
        <h2>Name {{ props.name }} </h2>
        <h3>Status {{props.disabled}}</h3>
    </div>
</template>
<style></style>
.....................................................................................
			One way data flow Model
.....................................................................................
All props forms a one way data flow model, where child component cant update the properties

			"Props are read only"

<script setup>
//const props = defineProps(['title'])
const props = defineProps({
    title: {
        type:String,
        default: 'Default Props'
    }
})
//update property - props are read only
props.title = "something"
</script>
<template>
    <div>
        <h1>{{props.title}}</h1>
    </div>
</template>
<style>

</style>

reactivity.esm-bundler.js:4 [Vue warn] Set operation on key "title" failed: target is readonly. Proxy
warn @ reactivity.esm-bundler.js:4
reactivity.esm-bundler.js:4 [Vue warn] Set operation on key "title" failed: target is readonly. Proxy
warn @ reactivity.esm-bundler.js:4
runtime-core.esm-bundler.js:38 [Vue warn]: Invalid prop: type check failed for prop "title". Expected String with value "100", got Number with value 100. 
  at <ProductDetails title=100 > 
  at <ProductMaster/>

....................................................................................
			   Event Handling
....................................................................................
Event handling is one of the most popular concept in javascript as part of DOM programming.
Event handling helps to interact with user.
Events  are signals triggered by user or system, send to os system, the software or hardware reacts according to the event.

Events are classified into two category

1.Hardware events
   Triggered by user or system, interacts with hardware devices   
eg:
  Mouse events
    onclick,ondblclick,onmouseenter...
  https://www.w3schools.com/jsref/obj_mouseevent.asp
  Keyboard events
   onkeypress,onkeydown
  https://www.w3schools.com/jsref/event_onkeypress.asp
  Touch events
  ontouchstart,ontouchend
  https://www.w3schools.com/jsref/obj_touchevent.asp

2.Application events
   attached with objects called dom objects
  onload,oncomplete

...................................................................................
		    How event handling works

Event handling has been designed based on the design pattern called "pub-sub"/observer design pattern.

There are two actors:
1.Producer
   The producer is something who sends signals(events - name of the event and data assoicated) to the listener
2.Listener
  The Listener is someone who waits/listens for event.
  Once the event is given who reacts/respond

In js :
 Listener is function.

//event is just reference to the Event Object having information about event, and data
function listener(event){
     event.target.value
}
event object is a bridge between producer and listener

In javascript , events are given by language itself.

events are started with "on+eventName" - 
 onclick="listener"

addEventListener('click',listener)
listeners are plain js functions with event object reference arg

Frameworks like vue,react,angular who adds their own abstractions.

We can attach event on any dom element which could be application or hardware


Vue Js and event handling:
..........................

Vue attaches events with any element with help of directive
                          "v-on"

Syntax:
1. v-on:NameOftheEvent="listener" -  v-on:click="update"
2. @click="listener" - @click="update"

Event Hanlding Options Api:
...........................

<!-- Event handling in options Api -->

<script>
export default {
    data() {
        return {
            counter: 0
        }
    },
    methods: {
        //listeners will go
        onIncrement(evt) {
            console.log('onIncrement')
        }
    }
}
</script>
<template>
    <div>
        <h1>Counter {{ counter }}</h1>
        <button v-on:click="onIncrement">Click</button>
        <button @:click="onIncrement">Click</button>

    </div>
</template>
<style></style>

Event listners in composition pattern: setup function.
<script>
export default {
    setup() {
        const counter = 0;
        //listener 
        const onIncrement = () => {
            console.log('onIncrement')
        }
        //you must return object , inside you should encaspulate listeners
        return {
            counter,
            onIncrement
        }
    }
}
</script>
<template>
    <div>
        <h1>Counter {{ counter }}</h1>
        <button v-on:click="onIncrement">Click</button>
        <button @:click="onIncrement">Click</button>

    </div>
</template>
<style></style>

<!-- Setup attribute -->
<script setup>
const counter = 0;
//listener 
const onIncrement = () => {
    console.log('onIncrement')
}
</script>
<template>
    <div>
        <h1>Counter {{ counter }}</h1>
        <button v-on:click="onIncrement">Click</button>
        <button @:click="onIncrement">Click</button>

    </div>
</template>
<style></style>
...................................................................................
		 How to attach more than one listener on single DOM Element
...................................................................................

<dom v-on:eventName="listener" v-on:eventName="listener">
<dom v-on="{mouseenter:onMouseEnter,mouseleave:onMouseLeave}">

<script setup>
const onMouseEnter = (evt) => {
    console.log('onMouseEnter')
}
const onMouseLeave = (evt) => {
    console.log('onMouseLeave')
}
</script>
<template>
    <div>
        <div v-on="{ mouseenter:onMouseEnter,mouseleave:onMouseLeave}">
            Touch
        </div>
    </div>
</template>
<style></style>
..................................................................................
			  How to pass data to the event listener
..................................................................................
const getData = (data,event) => {
    console.log(data,event)
}
 <button @click="getData('hello',$event)">Pass Data</button>

when we pass data to the listener, vue cant  pass event implicitly, we have to pass event object explicitly via "$event" which is global event object provided by vue.
....................................................................................
			  State - Reactive State
....................................................................................

State means data
How to change or update State?

React uses the concept called "pure functions" to change the state
Angular uses the concept called "Two way data" binding to change the state
Vue uses the concept called "Reactive state, /Reactivity" to change the state.

Component state consists of reactive javascript object , when you modify them, the view updates automatically.

Through event listener we modify the state of object(reactive),Ui gets lastest value.

There are various different programming patterns to change state in options and composition api.

Options Api:

 data function returns object which is by default "Reactive" , when ever you change that properties of the object, ui bindings gets updated automatically.

data() {
 //reactive state 
 return {
    count:0
 }
}
How to mutate?
methods: {
  onIncrement(){
    //mutate the reactive variable.
    this.count++ // mutation
  }

}

eg:
<script>
export default {
    data() {
        return {
            counter: 0
        }
    },
    methods: {
        onIncrement() {
            //access state and mutate
            this.counter++
        },
        onDecrement() {
            //access state and mutate
            this.counter--
        }
    }
}
</script>
<template>
    <div>
        <h1>Counter {{ counter }}</h1>
        <button @click="onIncrement">+</button>
        <button @click="onDecrement">-</button>

    </div>
</template>


Composition Api:Setup function

<script>
    export default {
        setup() {
            let counter = 0
            const onIncrement = () => {
                console.log(counter)
                counter++
            }
            const onDecrement = () => {

            }
            return {
                counter, onIncrement, onDecrement
            }
        }
    }
</script>
<template>
    <div>
        <h1>Counter {{ counter }}</h1>
        <button @click="onIncrement">+</button>
        <button @click="onDecrement">-</button>

    </div>
</template>

After running this code, 
	Here we are trying to mutate/update the "count" state variable, there is update happening but it does not trigger "view update /view rerender"

The reason because the variables are declared within setup function is not reactive variables by default rather which is local variables. so that vue engine will not trigger re render.

We have to convert that local variable into "reactive" variable.

How to declare reactive state or how to attach reactivity feature?

Compostion Api reactive methods:
................................
ref()
computed()
reactive()
readonly()
watchEffect()
watchPostEffect()
watchSyncEffect()
watch()
etc...

ref():
 It is function which returns Object, not value

function ref<T>(value: T): Ref<UnwrapRef<T>>

interface Ref<T> {
  value: T
}

Composition Api: with setup function:

<script>
import { ref } from 'vue'

export default {
    setup() {
        let counter = ref(0)
        const onIncrement = () => {
            console.log(counter.value)
            counter.value ++
        }
        const onDecrement = () => {
            counter.value --
        }
        return {
            counter, onIncrement, onDecrement
        }
    }
}
</script>
<template>
    <div>
        <h1>Counter {{ counter }}</h1>
        <button @click="onIncrement">+</button>
        <button @click="onDecrement">-</button>

    </div>
</template>
.....................................................................................

State Mutation with Setup attribute:
<script setup>
import { ref } from 'vue'
let counter = ref(0)
const onIncrement = () => {
    console.log(counter.value)
    counter.value++
}
const onDecrement = () => {
    counter.value--
}
</script>
<template>
    <div>
        <h1>Counter {{ counter }}</h1>
        <button @click="onIncrement">+</button>
        <button @click="onDecrement">-</button>

    </div>
</template>
...................................................................................
 Passing values to Listener and based on that value we can mutate UI.

<script setup>
import { ref } from 'vue'
let counter = ref(0)
const onIncrement = () => {
    console.log(counter.value)
    counter.value++
}
const onDecrement = () => {
    counter.value--
}
const onIncrementBy = (payload, event) => {
    counter.value += payload
}
</script>
<template>
    <div>
        <h1>Counter {{ counter }}</h1>
        <button @click="onIncrement">+</button>
        <button @click="onDecrement">-</button>
        <button @click="onIncrementBy(5, $event)">IncrementBy</button>

    </div>
</template>
....................................................................................
			InLine Event listener
....................................................................................

We dont need a separate listener function inside script, we can declare as part of the event binding.
<script setup>
import { ref } from 'vue'
let counter = ref(0)
const onIncrementBy = (payload, event) => {
    counter.value += payload
}
</script>
<template>
    <div>
        <h1>Counter {{ counter }}</h1>
        <button @click="counter++">+</button>
        <button @click="counter--">-</button>
        <button @click="onIncrementBy(5, $event)">IncrementBy</button>
    </div>
</template>
.....................................................................................
			Multiple Reactive Variables
.....................................................................................
<script setup>
import { ref } from 'vue'
let like = ref(0)
let dislike = ref(100)

</script>
<template>
    <div>
        <h1>Like {{ like }} Dislike {{ dislike }}</h1>
        <button @click="like++">Like</button>
        <button @click="dislike++">Dislike</button>
    </div>
</template>
.....................................................................................
Case Study:
  You have to create User compoent having user details
  1.basic user info - like id,firstName,lastName
  2.address - street,city,state,country,zipcode
  3.Logo - img
  4.location - lat, lng

 User
  |
  Address
  Logo
  Location

Pass props from the parent compoent to child
.....................................................................................					....................................................................................
			   Reactivity
....................................................................................

What is Reactivity?
  Reactivity is one of the core vue js concept.
Component state are "reactive javascript objects"

The word reactivity means "changing" the state(object),whenever changes happen it publishes some events, based on events,reactions happens.

Programming work flow in general

int x =10;
int y =20;

int result = x + y

when you compute this code, the runtime will execute instructions top-down pattern.
if there is change in variable (like x or y), will not update result variable
 -Sequential programming model.

What if i want to update the "result" variable value automatically when ever x or y changes.

eg:
Excel spreed sheet is one of the best eg for reactivitity programming

eg;

let A1=1
let A2=2
let A3 =A1+A2
console.log(A3) => 3

A2=4
console.log(A3) => 7

Here when you mutate A1 or A2, does not change automatically.

We can wrap this code inside function

 let A3
 function update(){
   A3 = A1 + A2
 }
 console.log(A3)
 if changes are dedecuted in A1 and A2 ->We need to rerun(update()
 update()
 console.log(A3)

in order get fresh value, we have to re-run the code that updates A3

Pointers:

1.There should be some update function, which produces a "side effect /effect".
  if any function which changes the state of the program called side effect.

2.Here ,A1 and A2 are considered dependencies of the side effect, because which helps makes side effects.
  According to dependencies, this effect is said to be "subscriber"

When ever "A1 and A2" changed, we need to invoke "update" function,which cause side effects.

It looks like event driven programming (Pub-Sub Pattern /Observerable and Observer) 

 function whenDepChange(update){
     update()
 }

 let A3
 function update(){
   A3 = A1 + A2
 }

 whenDepChange(function(){
     A3 = A1 + A2
 })
 whenDepChange(update)

Role of whenDepchange function:
................................

1.Tracking the dependencies,
    By evaulating the expression A1 and A2 ,Whether any one of them is read or not.

Vue Internal Reactivity WorkFlow:

Tracker--->triggers--whenDepChange--->runs update function---returns modified state
	
...................................................................................
			  Vue js and Reactivity

Vue js uses "Reactivity subsystem" in order to track all state variables, when ever which changes happen, it inform the vue engine for re render process..

In large scale we cant really track the reading and writing of local variables like the above example.
There is no any mechanism of doing that in "plain javascript". Instead of local variables what we can do , we can intercept the reading and writing of object propeties.

There are two implementations
1.Intercepting property access in javascript via getters and setters.
2.ES 6 has concept called "Proxies", through which we can track changes object 
properties.

In vue 2, setters and getters are used
In vue 3 ,Proxies are used.

Pseudo-code of Reactive apis in Vue js

function ref(value){
 const refObject={
    get value(){
	track(refObject,'value')
        return value
    }
    set value(newValue){
	value=newValue
	trigger(refObject,'value')
    }

 }
 return refObject
}

const proxy = ref(0)
proxy.value
....................................................................................
			 ref with literal object
....................................................................................

<script setup>
import { ref } from 'vue'
const counter = ref({ count: 0 })
const onIncrement = () => {
    counter.value.count++
}
</script>
<template>
    <div>
        <h1>Counter {{ counter.count }}</h1>
        <button @click="onIncrement">+</button>
    </div>
</template>
<style></style>
..................................................................................
		      reactive api

There is another way to declare reactive state, with reactive api.
Unlike a ref which wraps the inner value in special object, reactive makes an object itself reactive

<script setup>
import { reactive, ref } from 'vue'

const state = { count: 0 }
const counter = reactive(state)

console.log(counter === state)

const onIncrement = () => {
    counter.count++
}
</script>
<template>
    <div>
        <h1>Counter {{ counter.count }}</h1>
        <button @click="onIncrement">+</button>
    </div>
</template>
<style></style>

ref vs reactive:

1.reactive api takes objects as parameter like literal object,collection types such as array,map,set. It cant hold primtive types such as string ,number or boolean

2.ref can take any type of data.
....................................................................................
=>Reactive Conversion(changes) are even updated for deep nested objects 
=>Reactive api compares every property in the object before ui re renders for changes.

let obj={
 
  a:1
  b: {
    c: {
     d: {
	    e:0
     }
    }
  }
}

<script setup>
import { reactive } from 'vue';


const comments = reactive({
    like: 0, dislike: 0, recommend: {
        rating: {
            value: 0
        }
    }
})
</script>
<template>
     <h1>Reactive State</h1>
     <h1>Like : {{comments.like }} Dislike {{comments.dislike }} Rating Value {{comments.recommend.rating.value }}</h1>
     <button @click="comments.like++">Like</button>
     <button @click="comments.dislike++">Dislike</button>
     <button @click="comments.recommend.rating.value++">Rating</button>

</template>
<style></style>
..................................................................................
  	 How to avoid deep conversion with Reactive Nested Object
....................................................................................

Some times i am going update only outter properties, but by default vue engine compares every property in the object, which degrade performance.

There is an api which is built on the top of "reactive" called "shallowReactive"

shallowReactive:
  shallow version of reactive()
 Unlike reactive there is no deep conversion, only root properties are reactive.

<script setup>
import { shallowReactive } from 'vue';

const comments = shallowReactive({
    like: 0, dislike: 0, recommend: {
        rating: {
            value: 0
        }
    }
})
</script>
<template>
     <h1>Reactive State</h1>
     <h1>Like : {{comments.like }} Dislike {{comments.dislike }} Rating Value {{comments.recommend.rating.value }}</h1>
     <button @click="comments.like++">Like</button>
     <button @click="comments.dislike++">Dislike</button>
     <button @click="comments.recommend.rating.value++">Rating</button>

</template>
<style></style>
......................................................................................
...................................................................................
		   Reactivity ,State Mutation,and Object Destructuring
...................................................................................
After reactive object destructuring , can we do state mutations?
 

<script setup>
import { reactive } from 'vue';


const { like, dislike, recommend } = reactive({
    like: 0, dislike: 0, recommend: {
        rating: {
            value: 0
        }
    }
})
</script>
<template>
    <h1>Reactive State</h1>
    <h1>Like : {{ like }} Dislike {{ dislike }} Rating Value {{ recommend.rating.value }}</h1>
    <button @click="like++">Like</button>
    <button @click="dislike++">Dislike</button>
    <button @click="recommend.rating.value++">Rating</button>
</template>
<style></style>

After running this code, you will see nothing happens

   "Reactivity will be lost once if the object is destructured"

What if i want destructuring and also reactivity


How to convert destructured property into Reactive?

1.toRef - single property
2.toRefs - multiple property

eg:
<script setup>
import { reactive, toRefs } from 'vue';

const { like, dislike, recommend } = toRefs(reactive({
    like: 0, dislike: 0, recommend: {
        rating: {
            value: 0
        }
    }
}))
const onLike = () => {
    like.value++
}

</script>
<template>
    <h1>Reactive State</h1>
    <h1>Like : {{ like }} Dislike {{ dislike }} Rating Value {{ recommend.rating.value }}</h1>
    <button @click="onLike">Like</button>
    <button @click="dislike++">Dislike</button>
    <button @click="recommend.rating.value++">Rating</button>
</template>
<style></style>
...................................................................................
				Watchers
...................................................................................

What is Watcher?
   Watcher is a function, which allows us to monitor an application state and trigger actions based on these changes.
   Watchers that allows us to observe some data and perform specific actions when it changes.
   It is more generic way to observe and react to data changes in the vue instance.

 With watchers, we are not just able to watch a property and perform custom actions, we can also access the old value that is particular property is changing from, as well as the new value that it has changed to.

Watcher is Options Api:
......................
<script>
export default {
    data() {
        return {
            counter: 0
        }
    },
    watch: {
        counter(newValue, oldValue) {
            console.log('oldValue=>', oldValue, 'newValue=>', newValue)
        }
    }
}
</script>
<template>
    <h1>Counter {{counter }}</h1>
    <button @click="counter++">+</button>
</template>
<style></style>
....................................................................................
			Watchers in Composition Api using Setup function
.....................................................................................

<script>
import { ref, watch } from 'vue';

export default {
    setup() {
        const counter = ref(0)
        //watchers
        watch(counter, (newValue, oldValue) => {
            console.log('oldValue=>', oldValue, 'newValue=>', newValue)
        })

        return {
            counter
        }
    }
}
</script>
<template>
    <h1>Counter {{ counter }}</h1>
    <button @click="counter++">+</button>
</template>
<style></style>

....................................................................................
		Watchers in Composition Api using Setup attribute
.....................................................................................


<script setup>
import { ref, watch } from 'vue';

const counter = ref(0)
//watchers
watch(counter, (newValue, oldValue) => {
    console.log('oldValue=>', oldValue, 'newValue=>', newValue)
})
</script>
<template>
    <h1>Counter {{ counter }}</h1>
    <button @click="counter++">+</button>
</template>
<style></style>
....................................................................................
			 Object Properties and Watchers
....................................................................................
Watchers will trigger only when data is changed, meaning once the user starts interact or if any changes are deducted.

we may want to perform certain actions with initial value of the property we are watching for our app might require that we send an API request with inital data and then repeat the process if the data changes.

watch(comments, (newValue, oldValue) => {
    console.log('oldValue=>', oldValue)
    console.log('newValue=>', newValue)
 }, {
    // deep: true
    immediate: true
})


<script setup>
import { reactive, watch } from 'vue';

const comments = reactive({
    like: 0, dislike: 0, recommend: {
        rating: {
            value: 0
        }
    }
})
//watchers which watches all properties including ensted property
// watch(comments, (newValue, oldValue) => {
//     console.log('oldValue=>', oldValue, 'newValue=>', newValue)
//     console.log('old value=>', oldValue.recommend.rating.value)
//     console.log('new value=>', newValue.recommend.rating.value)

// })
//watchers which watches disable inner property changes

watch(comments, (newValue, oldValue) => {
    console.log('oldValue=>', oldValue)
    console.log('newValue=>', newValue)
  
}, {
    // deep: true
    immediate: true
})
</script>
<template>
    <h1>Reactive State with Watchers</h1>
    <h1>Like : {{ comments.like }} Dislike {{ comments.dislike }} Rating Value {{ comments.recommend.rating.value }}</h1>
    <button @click="comments.like++">Like</button>
    <button @click="comments.dislike++">Dislike</button>
    <button @click="comments.recommend.rating.value++">Rating</button>
</template>
<style></style>
....................................................................................
			watch is simpilifed with "watchEffect" api
.....................................................................................

<script setup>
import { ref, watch, watchEffect } from 'vue';

const counter = ref(0)
// //watchers
// watch(counter, (newValue, oldValue) => {
//     console.log('oldValue=>', oldValue, 'newValue=>', newValue)
// })
watchEffect(() => {
    console.log('Watcher => ', counter.value)
})
</script>
<template>
    <h1>Counter {{ counter }}</h1>
    <button @click="counter++">+</button>
</template>
<style></style>
....................................................................................
			 Watchers in Real time
...................................................................................

Real time conversion
Real data fetch.....

<script setup>
import { ref, watch } from 'vue';

const tmpCelsius = ref(0)
const tmpFarenheit = ref(0)

watch(tmpCelsius, newValue => {
    tmpFarenheit.value = Math.round((newValue * 9) / 5 + 32)
})

</script>
<template>
    <h1>TmpFarenheit {{ tmpFarenheit }}</h1>
    <button @click="tmpCelsius+=3">TmpFarenheit</button>
</template>
<style></style>
.....................................................................................
....................................................................................
				List Rendering -Arrays
....................................................................................
Arrays:
 =>Arrays are basic datastructure which is used to render collection of data
 =>Arrays are dynamic


Arrays and UI:
 if you want render more data, then array is used.
Arrays can help to build in UI layouts in various ways

UI layouts:
 are built with help of arrays.

1.List View
 <ul>
   <li>
 </ul>
2.Card View layout
  <div><header><section>
3.Grid view
  table

<script setup>
import { reactive } from 'vue';
import TODOS from './mock-data/todos'
const todos = reactive(TODOS)
</script>
<template>
    <div>
        <ul>
            <li v-for="todo in todos">
                <span>{{ todo.title }}</span>
            </li>
        </ul>
    </div>
</template>
<style></style>
...................................................................................
			 List with Index
..................................................................................
<script setup>
import { reactive } from 'vue';
import TODOS from './mock-data/todos'
const todos = reactive(TODOS)
</script>
<template>
    <div>
        <ul>
            <li v-for="(todo,index) in todos">
                <span> {{index}} {{ todo.title }}</span>
            </li>
        </ul>
    </div>
</template>
<style></style>
.....................................................................................
....................................................................................			                      Key
....................................................................................
if there is re ordering in the list when we do some changes like sorting, filtering 
vue uses an alogorthim called "path"

We can tell to that alogrthim we can re arrange , that where key attribute comes into picture

Key's value must be unique.

....................................................................................			                      Key
....................................................................................
if there is re ordering in the list when we do some changes like sorting, filtering 
vue uses an alogorthim called "path"

We can tell to that alogrthim we can re arrange , that where key attribute comes into picture

Key's value must be unique.

<script setup>
import { reactive} from 'vue'
import TODOS from './mock-data/todos'
//deep nesting
const todos = reactive(TODOS)

</script>
<template>
    <div>
      <ul>
        <li v-for="(todo,index) in todos" :key="todo.id">
          <!-- <span>{{index}} {{todo.title}}</span> -->
          <span>{{todo.title}}</span>
        </li>
      </ul>

    </div>
</template>
.....................................................................................
				Array Mutations
....................................................................................
Push, remove,update array elements

<script setup>
import { reactive } from 'vue';

const todos = reactive([])

const addItem = evt => {
    todos.push({ id: Math.random(), text: 'Learn Vue!' })
}
</script>
<template>
    <ul>
        <h1>Todo App</h1>
        <hr />
        <li v-for="todo in todos">
            <span>{{ todo }}</span>
        </li>
        <button @click="addItem">Add Todo</button>
    </ul>
</template>

In vue all array api will not trigger render cycle.

API which triggers render cycle - Mutatating apis

push
pop
shift
unshift
splice 
sort
reverse
...................................................................................
			  Displaying filtered/sorted Array
....................................................................................

Sometimes we want to display filtered or sorted version of an array without actually mutating or resetting the original data.

We are going to use array immutable apis.

What is immutable api?
 When ever we do any changes on object, instead of changing original object changes, which creates a new copy of the object -immuatble.

for eg, if you add any new item into array, the runtime will create new array, instead of mutating original memory.


Array immutable apis
map,filter,reduce
or
you can use spread operator or Object.assign method.

<script setup>
import { ref } from 'vue';
import TODOS from './mock-data/todos'
const todos = ref(TODOS)

const filter = () => {
    todos.value = todos.value.filter(todo => todo.completed)
}

</script>
<template>
    <div>
        <button @click="filter">FilterByStatus</button>
        <h1>Total Items: {{ todos.length }}</h1>
        <ul>
            <li v-for="todo in todos" :key="todo.id">
                <span>{{ todo.title }} {{ todo.completed ? "Completed" : "Not Completed" }}</span>
            </li>
        </ul>
    </div>
</template>
...................................................................................
			  Computed Properties
..................................................................................

In vuejs, there are serveral ways to set static or dynamic values to display on the template.
These include using text interpolation, directly hardcoding into your HTML or even using simple expressions to modify the data.

This is where computed properties come in super handy.

What are computed properties?

In vue js computed properties enable you to create a property that can be used to modify,manipulate, and display data within your components in a readable and efficient manner.

You can use computed properties to calculate and display values based on a value or set of values in the data model.

It can also have some custom logic that is cached based on its dependencies, even though page reloads, it does not change.

Eg;
Computed Properties in options api.

Without computed property to display value:
<script>
export default {
    data() {
        return {
            productNo: 2
        }
    }
}
</script>
<template>
    <div>
        <h1>{{ 'Your Product No ' + productNo }}</h1>
    </div>
</template>


With Computed Property:
<script>
export default {
    data() {
        return {
            productNo: 2
        }
    },
    computed: {
        product() {
            return `Your Product No is ${this.productNo}`
        }
    }
}
</script>
<template>
    <div>
        <!-- <h1>{{ 'Your Product No ' + productNo }}</h1> -->
        <h1>{{product}}</h1>
    </div>
</template>

Use cases of Computed Properties:
.................................
 Computed Properties are used to solve more complex problems

1.Filtering data
  Computing properties are great for filtering data.
for eg, lets say you are filtering an array from input search bar.

<script>
import TODOS from './mock-data/todos'
export default {
    data() {
        return {
            todos: TODOS,
            searchQuery: null
        }
    },
    computed: {
        resultQuery() {
            if (this.searchQuery) {
                //filter logic
                return this.todos.filter(item => {
                    console.log(item)
                    return this.searchQuery.toLowerCase().split(" ").every(v => item.title.toLowerCase().includes(v))
                });
            } else {
                return this.todos
            }
        }
    }
}
</script>
<template>
    <div>
        <div>
            <input v-model="searchQuery" type="text">
            <div v-for="todo in resultQuery" :key="todo.id">
                   <p> {{todo.id}} {{ todo.title }}</p> 
            </div>
        </div>
    </div>
</template>

Dynamic Computations: Dynamic calcualtions:
............................................
<script>
export default {
    data() {
        return {
            number: 2
        }
    },
    computed: {
        doubleIt() {
            return this.number * 2
        }
    }

}
</script>
<template>
    <h1>Value {{ doubleIt }}</h1>
</template>

Dynamic Toggling:
.................
<script>
export default {
    data() {
        return {
            status: true
        }
    },
    computed: {
        toggle() {
            if (this.status) {
                return true
            } else {
                return false
            }
        }
    }

}
</script>
<template>
    <h1>Value {{ toggle }}</h1>
    <button @click="status = !status">Toggle</button>
</template>
....................................................................................
		  Computed Properties and Composition api

setup attribute and setup function syntax remains same.

<script setup>
import { computed, ref } from 'vue';
const product = ref(2)
const productNo = computed(() => {
    return product.value
})
</script>
<template>
    <div>
        <h1>{{ productNo }}</h1>
    </div>
</template>

..
<script setup>
import { computed, reactive } from 'vue';
import TODOS from './mock-data/todos'
const state = reactive({ todos: TODOS, searchQuery: null })

const resultQuery = computed(() => {
    if (state.searchQuery) {
        return state.todos.filter(item => {
            return state.searchQuery.toLowerCase().split(" ").every(v => item.title.toLowerCase().includes(v))
        });
    } else {
        return state.todos
    }
});
</script>
<template>
    <div>
        <div>
            <input v-model="state.searchQuery" type="text">
            <div v-for="todo in resultQuery" :key="todo.id">
                <p> {{ todo.id }} {{ todo.title }}</p>
            </div>
        </div>
    </div>
</template>
.....................................................................................
			Caching and Computed Properties
		    (Normal Methods vs Computed Properties)

<script setup>
import { computed, reactive } from 'vue';

const author = reactive({
    name: 'Subramanian',
    trainings: [
        'Vue 3',
        'React js',
        'Microservices'
    ]
})
//computed method enables caching by default
const isTrainingDone = computed(() => {
    console.log('computed property method')
    return author.trainings.length > 0 ? "Yes" : "No"

})
//normal method gets called every time...
const isTrainingHandled = () => {
    console.log('Normal method')
    return author.trainings.length > 0 ? "Yes" : "No"
}
</script>
<template>
    <h1>{{ isTrainingDone }}</h1>
    <h1>{{ isTrainingHandled() }}</h1>

    <h1>{{ isTrainingDone }}</h1>
    <h1>{{ isTrainingHandled() }}</h1>
</template>
...................................................................................
			  Data sharing patterns
..................................................................................

There are many ways to share data in vue js

1.Parent to child - props pattern
2.Child to Parent  - Event Emitter Pattern
3.across application - Global pattern
.....................................................................................
                 Child to Parent- Event Emitter Pattern
....................................................................................

Child Component can emit event along with data, where as Parent Component can listen for data.

Event Emitter syntax:
In the child component

const emit = defineEmits(['change','remove','save'])

emit('OnNameofTheEvent',data)

In the Parent Component

<Child  @on-nameoftheevent="listener"/>

const listner = data=>{
  console.log(data)
}



eg:

Child Component
src/componets/CounterVue.vue
<script setup>
import { ref } from 'vue';
const counter = ref(0)
const emit = defineEmits(['onRequest'])
const onSend = () => {
    counter.value++
    emit('onRequest', counter.value)

}
</script>
<template>
    <h1>Child-Counter</h1>
    <button @click="onSend">SendToParent</button>
</template>


Parent Component:
src/App.vue

<script setup>
import { ref } from 'vue';
import Counter from './components/counter/CounterVue.vue'

const counter = ref(0)
const getChildData = data => {
    console.log(data)
    counter.value = data
}
</script>
<template>
    <h1>Parent</h1>
    <h2>Child Counter Data {{ counter}}</h2>
    <hr>
    <Counter @on-request="getChildData"></Counter>
</template>
....................................................................................
				Advanced Props
.....................................................................................

Already we have seen basic props, like how to pass data from the parent to child.

1.Dynamic props -  state as prop
2.HTML attributes as prop - Fall through Attributes
3.Component/DOM element as Prop- Slots


1.Dynamic props -  state as props

src/App.vue
<script setup>
import Counter from './components/dynamicprops/Counter.vue'
</script>
<template>
    <Counter></Counter>
</template>

src/components/dynamicprops/Counter.vue

<script setup>
import { ref } from 'vue';
import CounterDisplay from './CounterDisplay.vue';
// State Variable
const counter = ref(0)
</script>
<template>
    <h1>Counter</h1>
    <CounterDisplay :counter="counter"></CounterDisplay>
    <button @click="counter++">+</button>
</template>

src/components/dynamicprops/CounterDisplay.vue

<script setup>
const props = defineProps(['counter'])
</script>
<template>
    <h1>Counter Display {{ props.counter }}</h1>
</template>

....................................................................................
				CSS Integration
....................................................................................

css types:
1.global styles
2.component specific styles

assets/app.css
body {
    background-color: antiquewhite;
    margin-left: 50px;
}

h1 {
    font-family: 'Franklin Gothic Medium', 'Arial Narrow', Arial, sans-serif;
}

h2 {
    font-family: 'Lucida Sans', 'Lucida Sans Regular', 'Lucida Grande', 'Lucida Sans Unicode', Geneva, Verdana, sans-serif;
}

/* class */
.btn {
    padding: 0.8rem 1rem 0.7rem;
    border: 0.2rem solid #4d4d4d;
    cursor: pointer;
    text-transform: capitalize;
}

main.js
import './assets/app.css'

<script setup>
import { ref } from 'vue';
import CounterDisplay from './CounterDisplay.vue';
// State Variable
const counter = ref(0)
</script>
<template>
    <div class="box">
        <h1 style="color: blue;">Counter</h1>
        <CounterDisplay :counter="counter"></CounterDisplay>
        <button @click="counter++" class="btn">+</button>
    </div>
</template>
<style>
.box {
    background-color: aqua;
}
</style>
..................................................................................
				Dynamic Styling
..................................................................................
How to bind css classes dynamically?

Static class 
<div class="box">

</div>
Dynamic class
<div :class="{box:isActive}">

</div>
Apply box class based on "isActive" Property

<script setup>
import { ref } from 'vue';
const isActive = ref(false)

const hightLight = () => {
    if (isActive.value) {
        isActive.value = false
    } else {
        isActive.value = true
    }
}
</script>
<template>
    <h1 @mouseover="hightLight" :class="{ active: isActive }">Hello</h1>
</template>
<style>
.active {
    color: red;
}
</style>
...................................................................................
			Fall through attributes
....................................................................................

Attribute in heritance. (HTML attributes(class) as prop)
........................................................

A Fall through attribute is an an attribute or v-on listeners that is passed to component but it is not explcitly declared in the receiving components(child components) via props or emits.

   Properties which are inherited from the parent component to child component 
	      "class,style, and id attributes"



App.vue
<script setup>
import { ref } from 'vue';
import MyButton from './components/attributeinheritence/MyButton.vue'

const title = ref('Click')
</script>
<template>
    <MyButton :title="title" class="fancy-btn"></MyButton>
</template>
<style>
.fancy-btn {
    background-color: #4CAF50;
    border: none;
    color: white;
    padding: 15px 32px;
    text-align: center;
    text-decoration: none;
    display: inline;
    font-size: 16px;
}
</style>

MyButton.vue
<script setup>
const props = defineProps(['title'])
</script>
<template>
    <button>{{ props.title }}</button>
</template>
<style>
</style>

Now you can see output the button automatically inherited the property
....................................................................................
 How to access the attributes passed from parent in the child compoent

Two places:

1.inside template
2.inside script block


<script>
export default {
    created(){
        console.log(this.$attrs)
    }
}
</script>

using setup attribute 
import { useAttrs } from 'vue'
const attrs = useAttrs()

<script setup>
import { useAttrs } from 'vue'
const props = defineProps(['title'])
const attrs = useAttrs()
console.log(attrs)
</script>
<template>
    <!-- <button>{{ props.title }}</button> -->
    <span>{{$attrs}}</span>
</template>
<style>
</style>

What if i have container element?

<template>
    <div>
        <button>{{ props.title }}</button>
    </div>
</template>
now you can see output applied to only div element not button element.
what if i want to apply.

we need to bind expliclity using "v-bind=$attrs"

<template>
    <!-- <button>{{ props.title }}</button> -->
    <span>{{$attrs}}</span>
    <div style="background-color: cadetblue;">
        <button v-bind="$attrs">{{ props.title }}</button>
    </div>
</template>

What if i have multiple button elements?

  <div style="background-color: cadetblue;">
        <button v-bind="$attrs">{{ props.title }}</button>
    </div>
    <hr/>
    <div style="background-color: cadetblue;">
        <button v-bind="$attrs">{{ props.title }}</button>
    </div>
.....................................................................................
		Can we override parent class attribute in child compoent

Yes! but by default which is not overriden.

How to to override?

<style scoped>
.fancy-btn {
    background-color: #57222c;
}
</style>

We need to add "scoped" attribute 
.....................................................................................
What if i dont want attribute inheritance?

Note: 
 If single only single element  attribute inheritance  can be stopped

<script setup>
defineOptions({
    inheritAttrs: false
})
</script>
<template>
 <button>
</template>

eg:
<script setup>
defineOptions({
    inheritAttrs: false
})
const props = defineProps(['title'])
</script>
<template>
    <button>{{ props.title }}</button>    
</template>
<style>
.fancy-btn {
    background-color: #57222c;
}
</style>

If template is having multiple elements,attribute inheritance is enabled always.
.....................................................................................
			Component as Prop/DOM element as Prop
				 (Slot)
.....................................................................................
How to represent components?
  <MyComponent>
	 ? -  child elements - it could be dom element or another component
 </MyComponent>
 <MyComponent/>- Component has no childrens

<MyCompoent>
	You are sending html element or another component =>Slot Content
</MyComponent>

In order to access element or component as prop inside child compoent vue offers built in component "slot" -  which is place holder where the elements to be inserted.

Parent Component src/App.vue

<script setup>
import ChildSlot from './components/slots/ChildSlot.vue';

</script>
<template>
    <div>
        <h1>Parent</h1>
        <ChildSlot>
                <!-- Pass dom element as prop -->
                <h1>DOM element as Prop</h1>
        </ChildSlot>
    </div>
</template>

Child component src/components/slots/ChildSlot.vue

<script setup>

</script>
<template>
     <div>
        <h1>Child </h1>
        <hr>
        <slot></slot>
     </div>
</template>
....................................................................................
			   Fallback Content
////////////////////////////////////////////////////////////////////////////////////

<script setup>
import ChildSlot from './components/slots/ChildSlot.vue';

</script>
<template>
    <div>
        <h1>Parent</h1>
        <ChildSlot>
        </ChildSlot>
        <ChildSlot>
            <h1>Here i am passing</h1>
        </ChildSlot>
    </div>
</template>

Child component src/components/slots/ChildSlot.vue

<script setup>

</script>
<template>
     <div>
        <h1>Child </h1>
        <hr>
        <slot>
		
	</slot>
     </div>
</template>
.....................................................................................
				Component as Prop
.....................................................................................

src/components/slots/Image.vue
<script setup>

</script>
<template>
    <img src="../../assets/logo.svg" height="100" width="100" />
</template>

src/components/slots/Image.vue
<script setup>

</script>
<template>
    <div>
        <slot>
            
        </slot>
    </div>
</template>

src/App.vue
<script setup>
import Panel from './components/slots/PanelVue.vue'
import Image from './components/slots/Image.vue'
</script>
<template>
    <Panel>
        <Image />
    </Panel>
</template>
...................................XXXXX...........................................
				Multi Slot
...................................................................................

We can have more than one Slots

Without slot
<Layout>
  <Header/>
  <Body/>
  <Footer/>
</Layout>

<Layout>
  <Header>
	<!--Header information -->
  </Header>
  <Body>
	<!--Body information -->
  </Body>
  <Footer>
       <!--Footer information -->
  </Footer>
</Layout>

eg:
Child
<slot name="header"></slot>
Parent
<template v-slot:header>

</template>
App.vue -Parent:
<script setup>
import Layout from './Layout.vue'
</script>
<template>
    <h1>Vue Application</h1>
    <Layout>
        <template v-slot:header>
            <h1>Header</h1>
        </template>
        <template v-slot:main>
            <p>This is body</p>
        </template>
        <template v-slot:footer>
            <h3>Footer</h3>
        </template>
    </Layout>
</template>
<style>

</style>

Child

Layout.vue

<script setup>

</script>
<template>
    <header>
        <slot name="header">
            <h1>Default Header</h1>
        </slot>
    </header>
    <main>
        <slot name="main">
            <p>This is default Main</p>
        </slot>

    </main>
    <footer>
        <slot name="footer">
            <h1>Default Footer</h1>
        </slot>

    </footer>
</template>
<style>

</style>
................................................................................
	 Without V-Slot Directive , we can use #name

      <template v-slot:header>
            <h1>Header</h1>
        </template>
        <template v-slot:main>
            <p>This is body</p>
        </template>
        <template v-slot:footer>
            <h3>Footer</h3>
        </template>


      <template #header>
            <h1>Header</h1>
        </template>
        <template #main>
            <p>This is body</p>
        </template>
        <template #footer>
            <h3>Footer</h3>
        </template>

eg:
<script setup>
import Layout from './components/slots/Layout.vue'
</script>
<template>
    <h1>Vue Application</h1>
    <Layout>
        <!-- <template v-slot:header>
            <h1>Header</h1>
        </template>
        <template v-slot:main>
            <p>Body</p>
        </template>
        <template v-slot:footer>
            <h3>Footer</h3>
        </template> -->
        <template #header>
            <h1>Header</h1>
        </template>
        <template #main>
            <p>Body</p>
        </template>
        <template #footer>
            <h3>Footer</h3>
        </template>
    </Layout>
</template>

.....................................................................................
				Default slots
....................................................................................
The slot without name is called "default slot"

In case of multi slot , we can make any slot as default one.

Child:
    <main>
        <!-- <slot name="main">
            <p>This is default Main</p>
        </slot> -->
        <!-- Default Slot : Slot without Name -->
        <slot>
            <p>This is default Main</p>

        </slot>

    </main>

Parent:
 <template #default>
 </template>
eg:
Parent Component
<script setup>
import Layout from './Layout.vue'
</script>
<template>
    <h1>Vue Application</h1>
    <Layout>
        <!-- <template v-slot:header>
            <h1>Header</h1>
        </template>
        <template v-slot:main>
            <p>This is body</p>
        </template>
        <template v-slot:footer>
            <h3>Footer</h3>
        </template> -->
        <template #header>
            <h1>Header</h1>
        </template>
        <template #default>
            <p>This is body</p>
        </template>
        <template #footer>
            <h3>Footer</h3>
        </template>
    </Layout>
</template>
<style>

</style>

child Component:

<script setup>

</script>
<template>
    <header>
        <slot name="header">
            <h1>Default Header</h1>
        </slot>
    </header>
    <main>
        <!-- <slot name="main">
            <p>This is default Main</p>
        </slot> -->
        <!-- Default Slot : Slot without Name -->
        <slot>
            <p>This is default Main</p>

        </slot>

    </main>
    <footer>
        <slot name="footer">
            <h1>Default Footer</h1>
        </slot>

    </footer>
</template>
<style>
....................................................................................
				...................................................................................
				Dynamic Slots
...................................................................................

The slot name can be dynamic

Static slot:

<template v-slot:header>
<template #header>
<template #default>


Dynamic Slot:

const header = ref('header')

<template v-slot:[header]>
<template #[header]>



Dynamic Slot:

const header = ref('header')

<template v-slot:[header]>
<template #[header]>

<script setup>
import { ref } from 'vue';
import Layout from './Layout.vue'

const header =ref('header')
</script>
<template>
    <h1>Vue Application</h1>
    <Layout>
        <!-- <template v-slot:header>
            <h1>Header</h1>
        </template>
        <template v-slot:main>
            <p>This is body</p>
        </template>
        <template v-slot:footer>
            <h3>Footer</h3>
        </template> -->
        <template #[header]>
            <h1>Header</h1>
        </template>
        <template #default>
            <p>This is body</p>
        </template>
        <template #footer>
            <h3>Footer</h3>
        </template>
    </Layout>
</template>
<style>
</style>
.....................................................................................

....................................................................................
			   Slots Scope
....................................................................................
Slots scope enable data accssibility(sharing) for parent and child components.

There are two slot scope
1.Render scope
2.Scoped slots

Render Scope:
............
Slot content has access to the data scope of the parent component, because it is defined in the parent. For example:

<span>{{ message }}</span>
<FancyButton>{{ message }}</FancyButton>

Here both {{ message }} interpolations will render the same content.

Slot content does not have access to the child component's data. Expressions in Vue templates can only access the scope it is defined in, consistent with JavaScript's lexical scoping. In other words:

Expressions in the parent template only have access to the parent scope; expressions in the child template only have access to the child scope.

	 "As rule of thumb every thing in the template compiled in the parent scope;
          every thing is compiled in the child template in the child scope"


Scoped Slots:
.............
   if you want to access data in the parent and child scope.

  "if parent component want to access child  state(data),the child can pass data to   parent via "slot" when rendering it"

  Slot can act as bridge between parent and child for data transfer.

Syntax:
 <slot :firstName="firstName" :age="age" />


eg:
Child -ScopeSlot.vue
<script setup>
import {ref} from 'vue'
const message = ref('Hello')

</script>
<template>
    <!-- send data to parent via slot -->
    <slot :message="message"></slot>
</template>
<style>
</style>

Parent:
App.vue
<script setup>
import ScopeSlot from './ScopeSlot.vue';

</script>
<template>
    <h1>Scoped Slots</h1>
    <ScopeSlot v-slot="slotprops">
        {{slotprops.message}}
    </ScopeSlot>
</template>
<style>
</style>
...................................................................................
*************************************************************************************
**************************************************************************************			 Dependency Injection: Composition API
....................................................................................

Prop Driling:

 When you pass data from the parent component to child, from child to its child and so on, at each level you have to pass props manually

                         Root
			 |
			 props
			 |
			Child1
			 |props
			Child2
			 |props
			Child3
			 |props
		        Child-N


<script setup>
import { ref } from 'vue';
import Child1 from './propsdrilling/Child1.vue';
const message = ref('Hello')
</script>
<template>
    <h1>Root</h1>
    <Child1 :message="message" />
</template>

Child1.vue
<script setup>
import Child2 from './Child2.vue';
const props = defineProps(['message'])
</script>
<template>
    <h1>Child 1</h1>
    <Child2 :message="props.message" />
</template>

Child2.vue
<script setup>
import Child3 from './Child3.vue';
const props = defineProps(['message'])

</script>
<template>
    <h1>Child 2</h1>
    <Child3 :message="props.message" />
</template>

Child3.vue
<script setup>
const props = defineProps(['message'])

</script>
<template>
    <h1>Child 3 {{ props.message }}</h1>
</template>

..
What if  i want to access the data which is supplied in the root component into the deepest child component.

We can solve props drilling with "provide and inject".

Parent component can act as dependency provider to all its decendants.

Any component in the decendants tree, regardless of how deep it is, can inject dependencies provided by components up in its parent chain.

  			Root -  Provide
			 |        |
			props     |
			 |        |
			Child1    |
			 |        |
			Child2    |
			 |        |
			Child3    |
			 |        |
		        Child-N - Inject


eg:

Parent : App.vue

<script setup>
import { provide, ref } from 'vue';
import Child1 from './components/propsdrilling/Child1.vue';
const message = ref('Hello')
provide("message", message)
</script>
<template>
    <h1>Parent</h1>
    <Child1 ></Child1>
</template>
<style>

</style>

Child1.vue
<script setup>
import Child2 from './Child2.vue';

</script>
<template>
    <h1>Child1</h1>
    <Child2></Child2>
</template>
<style>

</style>

Child2.vue
<script setup>
import Child3 from './Child3.vue';

</script>
<template>
        <h1>Child2</h1>

    <Child3></Child3>
</template>
<style>
</style>

Child3.vue
<script setup>
import { inject } from 'vue';

const message = inject('message')
</script>
<template>
    <h1>Child3</h1>
    <h1>Data From the Parent {{message}} </h1>
</template>
<style>

</style>

What if multiple properties to be passed ?

// provide("message", message)
// provide("counter",counter)

provide('info',{counter,message})


const message =inject('message')
const {message,counter} =inject('info')

what if i dont provide?
 we can have default values

const message = inject('message','default Message')
....................................................................................
Provide and inject is used to share data in the component tree.
Provide and inject can also be used to share data globally.

How to share data globally?
 with help of application/app object 

app.provide			

...................................................................................
			            App Level Data sharing

You have to provide via app object.

app.provide('company','google')

main.js
import { createApp } from 'vue'
import App from './App.vue'

createApp(App)
    .provide('company', 'google')
    .mount('#app')

In any component:
<script setup>
import { inject } from 'vue'
const props = defineProps(['message'])

// const name = inject('name', 'default Name')
// const counter = inject('counter', 0)
const { name, counter } = inject('info')
const company = inject('company')
</script>
<template>
    <h1>Child 3 {{ props.message }}</h1>
    <h1>Tree level Global Data {{ name }} {{ counter }}</h1>
    <h1>App level Global Data {{ company }}</h1>

</template>

...................................................................................
			can we mutate the provider data


Yes we can override the provider data in child component

let companyName = inject('companyName')

companyName = 'Google'

What if i dont want to override? how to declare provider data read only.

App.v
<script setup>
import { provide, ref, readonly } from 'vue';
import Child1 from './components/providers/Child1.vue';
const message = ref('Hello')
provide('message', readonly(message))
</script>
<template>
    <h1>Root</h1>
    <Child1 />
</template>

Child3:
<script setup>
import { inject } from 'vue';
// const message = inject('message')
//default value
// const message = inject('message','default Message')

let message = inject('message')

let companyName = inject('companyName')
console.log(message)
message.value = 'How are you'

console.log(message)
</script>
<template>
    <h1>Child 3 {{message }}  {{companyName }}</h1>
</template>
.....................................................................................

....................................................................................
....................................................................................
.................................**************************..........................
			  Form Handling
.....................................................................................

Form Controls:
1.text / password
2.Multi line text
3.checkbox
4.radio
5.select
6.submit
7.reset


How to get input from the keyboard via form controls and bind in the ui


Syntax:

<input @input="listener" >
<script setup>

const getInput = ()=>{

}

</script>
<template>
    <h1>Forms</h1>
    <input @input="getInput" />
</template>
<style>

</style>

How to read value from the form controls?

1.using event object
2.using two way data binding

1.using event object
<script setup>

const getInput = evt=>{
  const value = evt.target.value
  console.log(value)
}

</script>
<template>
    <h1>Forms</h1>
    <input @input="getInput" />
</template>
<style>

</style>

How to bind data which got from keyboard?

<script setup>
import { ref } from 'vue';

const name = ref('')

const getInput = evt=>{
  const value = evt.target.value
  console.log(value)
  name.value = value
}

</script>
<template>
    <h1>Forms</h1>
     <p>{{name}}</p>
    <input @input="getInput" />
</template>
<style>

</style>


Two way data binding:

When ever user interacts via typing in the text box, the reactive variable is updated,
when ever reactive variable is updated, the UI is rerendered.


:value property  is used to initalize the default reactive state variable in side text box

<script setup>
import { ref } from 'vue';


const name = ref('default Name')
const getInput = evt=>{
  const value = evt.target.value
  console.log(value)
  name.value = value
}

</script>
<template>
    <h1>Forms</h1>
     <p>{{name}}</p>
    <input @input="getInput" :value="name" />
</template>
<style>

</style>
.....................................................................................
				How to reduce listeners
....................................................................................
When we have more input fields, we need to write more event listeners, which can be avoided in two ways

1.inline event listener

<script setup>
import { ref } from 'vue';
const name = ref('default Name')
</script>
<template>
    <h1>Forms</h1>
     <p>{{name}}</p>
    <input @input="evt=>name=evt.target.value" :value="name" />
</template>
<style>

</style>

2.Using v-model directive

 ->It removes explicit event binding ,which attaches the default event handler and event automatically.
 
<script setup>
import { ref } from 'vue';
const name = ref("defaultName")

</script>
<template>
    <div>
        <p>{{name}}</p>
        <input v-model="name"/>
    </div>
</template>

v-model directive can be used on other input controls as well.

textarea
  it uses value property and input event
checkbox
radio
  It uses checked property and change event
select
 It uses value property and input event 

TextArea:
..........

Using Text area , we can get multi line input
<script setup>
import { ref } from 'vue';

const mail = ref('')

</script>
<template>
  
    <div>
        <h2>{{ mail }}</h2>
        <label id="mail">Mail</label>
        <textarea v-model="mail" />
    </div>
</template>

Checkbox 

Single Checkbox:
<script setup>
import { ref } from 'vue';
const checked = ref(true)

</script>
<template>
    <div>
        <input type="checkbox" id="checkbox" v-model="checked" />
        <label for="checkbox">{{checked}}</label>
    </div>
</template>
................................................................................
Multi Checkbox value collection:
...............................

<script setup>
import { ref } from 'vue';

const values = ref([])

</script>
<template>
    <div>
        <h1>Course Information</h1>

        <input type="checkbox" id="frontend" value="frontEnd" v-model="values" />
        <label for="frontend">Front End</label>
        <input type="checkbox" id="backend" value="BackEnd" v-model="values" />
        <label for="backend">Back End</label>
        <input type="checkbox" id="devops" value="Dev Ops" v-model="values" />
        <label for="devoops">Dev Ops</label>
    </div>
    <div>
        {{ values }}
    </div>
</template>
....................................................................................
Radio Button:
............
<script setup>
import { ref, computed } from 'vue';

const choice = ref("Male")


</script>
<template>
    <div>
        <h1>Select any One</h1>
        <input type="radio" id="Male" value="Male" checked v-model="choice" />
        <label for="Male">Male</label>
        <input type="radio" id="Female" value="Female" v-model="choice" />
        <label for="Female">FeMale</label>
    </div>
    <div>
        {{ choice }}
    </div>
</template>
.................................................................................

Select:
<script setup>
import { ref, computed } from 'vue';

const selected = ref('')
const courses = ref(["Vue", "React", "Angular", "MicroServices"])
const selectedCourse = ref('')
</script>
<template>
    <div>
        <select v-model="selected">
            <option disabled value>Select Your choice</option>
            <option>Vue</option>
            <option>React</option>
            <option>Angular</option>
            <option>MicroServices</option>
        </select>
    </div>
    <div>
        {{ selected }}
    </div>
    <hr />
    <div>
        <select v-model="selectedCourse">
            <option disabled value>Select Your choice</option>
            <option v-for="course of courses">{{ course }}</option>
        </select>
    </div>
    <div>
        {{ selectedCourse }}
    </div>
</template>
...................................................................................

...................................................................................
			           Advanced Form Binding Properties
...................................................................................
Value Bindings -vue custom attributes:
......................................

v-model=""
true-value="yes" //replace true or false value into meaningfull values 
false-value="no"

<script setup>
import { ref } from 'vue';
const toggle = ref(true)
const truthyValue="Yes"
</script>
<template>
    <div>
        <input type="checkbox" :true-value="truthyValue" checked false-value="no" v-model="toggle" />
        <label for="Toggle">Toggle</label>
    </div>
    <div>
        <!-- {{toggle ? "Yes" : "No"}} -->
        {{ toggle }}
    </div>
</template>

For Radio button

:true-value=""

For Select options

:value="{text: 'some text'}"

....................................................................................
		Form Submission and How to prevent default events
....................................................................................

In java script, when you submit form, automatically there is event is fired , which is called "onSubmit" event.

onSubmit event by default looks the server url to be posted.

      <form action="http://www.google.com">
          <button>Submit</button>
      </form>

Here , the button tries to redirect to the url mentioned in the action property.

I need to control, the form submission manually.

Event Object :

has api called "preventDefault()" , which does not trigger auto form submission.


<script setup>

const onSubmit = event => {
    if (event) {
        event.preventDefault();
    }
}

</script>
<template>
    <div>
        <form action="http://www.google.com">
            <button @click="onSubmit">Submit</button>
        </form>
    </div>
</template>

Vue has some short cuts, instead of giving this inside listener, we can give inside templates.

Event Modifiers:
...............

Event Modifiers are used with v-on

<form @submit.prevent="onSubmit">

<script setup>

const onSubmit = event => {
    alert('Form to be Submitted')
}

</script>
<template>
    <div>
        <form @submit.prevent="onSubmit">
            <button>Submit</button>
        </form>
    </div>
</template>

Other event modifiers

//event propagation to be stopped
<a @click.stop="listner">

I want to submit form when key board events

<input @keyup.enter="onSubmit">

other keyboard keys modifiers

.enter
.tab
.left
.right
.space
.down
.up

.ctrl
.alt
.shift
.meta
.enter
.....................................................................................

Build Registration form:
=>Use Layouts - Header,Body,Footer- Use Slots
=>Create  User Registration form 
=>Submit the form details to the Parent
.....................................................................................
.....................................................................................
				 Component Life Cycles
.....................................................................................

Component has two phases of life cycles

1.mount
     inital render - when component is initalized
2.unmount
    when component is removed
Methods:
 onMounted,onUpdated,onUnMounted

onMounted method is generally and mostly used method
  Used to initalize api calls,timers,websockets connections.

<script setup>
import { onBeforeMount, onMounted, onUpdated, ref } from 'vue';

const counter = ref(0)
onBeforeMount(() => {
    console.log('onBefore Mount')
})
onMounted(() => {
    console.log('onMounted')
})
onUpdated(() => {
    console.log('OnUpdated')
})
</script>
<template>
    <div>
        <h1>Component life cycle methods</h1>
        <span @click="counter++">{{ counter }}</span>
    </div>
</template>

.....................................................................................
			   API calls in vue
.....................................................................................
Patterns:
1.you can write api call within component
2.you can write api call outside component using composable
3.you can write api call outside component using state management libs

Vue has no any opinion to select lib for making api calls, you can use fetch,axios.

Api calls can be made during inital page render-mounted
Api calls can be made during user interaction.

.....................................................................................
			   Ajax calls/api calls from vue
....................................................................................
<script setup>
import { onMounted, ref } from 'vue';

const data = ref(null)
const error = ref(null)

const fetchData = async () => {
    const url = 'https://jsonplaceholder.typicode.com/todos'
    try {
        const response = await fetch(url)
        const todos = await response.json()
        //update state 
        data.value = todos;
        console.log(data.value)
    }
    catch (err) {
        error.value = err
    }
}

onMounted(() => {
    fetchData()
})
</script>
<template>
    <div>
        <h1>Todo App</h1>
        <!-- Conditional rendering : v-if...v..else-if -->
        <div v-if="error">{{ error.message }}</div>
        <div v-else-if="data">
            <ul>
                <li v-for="todo of data">
                    {{ todo.title }}
                </li>
            </ul>
        </div>
        <div v-else>
            <h1>Loading...</h1>
        </div>
    </div>
</template>
.....................................................................................
			     Composables - Hooks
....................................................................................

What is a "Composable"?
 
  In the context of Vue applications, "Composables" are just plain javascript function that leverages Vue's Composition API to encapuslate and reuse "Stateful logic".

When we building frontend applications, we often need to resuse logic for common tasks. for example we may need to formate dates in many places, so extract a resuable function for that.

Statfull logic is that manage /update state that changes over time.

Lets begin with simple example called mouse tracker.

I need to track mouse pointer position.

<!-- Mouse tracking within component -->
<script setup>
import { onMounted, onUnmounted, ref } from 'vue';
const x = ref(0)
const y = ref(0)

const update = evt => {
    x.value = evt.pageX
    y.value = evt.pageY
}
onMounted(() => {
    //dom listener
    window.addEventListener('mousemove', update)
})
onUnmounted(() => {
    window.removeEventListener('mousemove', update)
})
</script>
<template>
    <h1>Mouse Positions are at X:{{ x }} And Y {{ y }}</h1>
</template>

In the example mouse tracking feature is locked with in this component, what if i want the same logic inside another component.

Ans : 
  Composables.

=>Composables is just plan js function
=>composables must be written inside another folder called "composables"
=>file name is "moustracker.js"

moustracker.js

 Name of the function should begin "useFunctionName".

export function useMouseTrack() {

}
The function may take args and also may return values...


eg:

src/composables/mousetracker.js
import { onMounted, onUnmounted, ref } from 'vue';

export function useMouseTrack() {
    const x = ref(0)
    const y = ref(0)
    const update = evt => {
        x.value = evt.pageX
        y.value = evt.pageY
    }
    onMounted(() => {
        //dom listener
        window.addEventListener('mousemove', update)
    })
    onUnmounted(() => {
        window.removeEventListener('mousemove', update)
    })
    return {
        x, y
    }
}
src/components/App.vue
<!-- Mouse tracking within component -->
<script setup>
import { useMouseTrack } from './composables/moustracker'
const { x, y } = useMouseTrack()
</script>
<template>
    <h1>Mouse Positions are at X:{{ x }} And Y {{ y }}</h1>
</template>

Note:  
 You have isloate the code as much as possible.


src/composables/event.js
import { onMounted, onUnmounted, ref } from 'vue';

export function useEventListener(target, event, callback) {

    onMounted(() => {
        //dom listener
        target.addEventListener(event, callback)
    })
    onUnmounted(() => {
        target.removeEventListener(event, callback)
    })
}

	
src/composables/mousetracker.js	
import { ref } from 'vue'
import { useEventListener } from './event'

export function useMouseTrack() {
    const x = ref(0)
    const y = ref(0)
    useEventListener(window, 'mousemove', evt => {
        x.value = evt.pageX
        y.value = evt.pageY
    })
    return {
        x, y
    }
}
....................................................................................
			API and Composables-Async State
....................................................................................

src/composables/fetch.js

import { ref } from 'vue';

export function useFetch(url) {
    const data = ref(null)
    const error = ref(null)
    async function init() {
        try {
            const response = await fetch(url)
            const items = await response.json()
            //update state 
            data.value = items;
        }
        catch (err) {
            error.value = err
        }
    }
    init()
    return {
        data, error
    }
}

src/App.vue
<script setup>
import { useFetch } from './composables/fetch'
const { data, error } = useFetch('https://jsonplaceholder.typicode.com/todos')
</script>
<template>
    <div>
        <h1>Todo App</h1>
        <!-- Conditional rendering : v-if...v..else-if -->
        <div v-if="error">{{ error.message }}</div>
        <div v-else-if="data">
            <ul>
                <li v-for="todo of data">
                    {{ todo.title }}
                </li>
            </ul>
        </div>
        <div v-else>
            <h1>Loading...</h1>
        </div>
    </div>
</template>
.....................................................................................
			Accepting Reactive state
....................................................................................

 useFetch('https://jsonplaceholder.typicode.com/todos')
  It takes a static URL string as input, so it performs the fetch only once and is then done.

What if we want it to re-fetch whenver the url changes? in order to achive this, we to pass reactive state into the composable function,and let the composable create watchers that performs actions using the passed state.

const url = 'https://jsonplaceholder.typicode.com/todos' -static url

const url = ref('https://jsonplaceholder.typicode.com/todos') -reactive url.

url.value = '/new-url' - trigers re-fetch

or 
const {data,error} = useFetch(()=> `/todos/${id}`);


eg:
fetch.js 
import { ref, watchEffect, toValue } from 'vue';

export function useFetch(url) {
    const data = ref(null)
    const error = ref(null)
    
    watchEffect(() => {
        data.value = null;
        error.value = null;
        async function init() {
            try {
                //we cant pass reactive variable directly into fetch 
                //we need to convert into value 
                const response = await fetch(toValue(url))
                const items = await response.json()
                //update state 
                data.value = items;
            }
            catch (err) {
                error.value = err
            }
        }
        init()
    })
    return {
        data, error
    }
}

App.vue
<script setup>
import { ref } from 'vue';
import { useFetch } from './composables/fetch'
const url = ref('https://jsonplaceholder.typicode.com/todos')

const { data, error } = useFetch(url)
</script>
<template>
    <div>
        <h1>Todo App</h1>
        <!-- Conditional rendering : v-if...v..else-if -->
        <div v-if="error">{{ error.message }}</div>
        <div v-else-if="data">
            <ul>
                <li v-for="todo of data">
                    {{ todo.title }}
                </li>
            </ul>
        </div>
        <div v-else>
            <h1>Loading...</h1>
        </div>
    </div>
</template>


Now vue starts using lot of composable apis, which ias every growing....
https://vueuse.org/

<script setup>
import useFetch from './composables/useFetch.js'
import { useTitle } from '@vueuse/core'

const url = 'https://jsonplaceholder.typicode.com/todos'
const title = useTitle('New Titlte', { titleTemplate: '%s My Awesome Website' })

const { data, error } = useFetch(url)
</script>
<template>
    <div>Todo App</div>
    <div v-if="error">Opps! Error Encountered</div>
    <div v-else-if="data">
        <div v-for="todo of data">
            <p>{{todo.title}}</p>
        </div>
    </div>
    <div v-else>
        <h1>Loading...</h1>
    </div>
</template>
<style>

</style>
.....................................................................................
				Custom Directives
.....................................................................................

Code Reuse in Vue:

The application code can be reused in vue in various ways.

1.Composables
   Way to reuse app state logic
2.Components
   Way to resue UI 
3.Directives 
   Way to resue underlaying dom features

There are different types of directives 

1.built in directives
   Directives are provided by vue - v-on,v-bind....
2.custom directives


How to create simple custom Directive?

Directive is object, having low level dom features.

Steps:

1.create directive object
<script setup>
//first directive
const vFocus = {
    //define life cycle methods
    mounted: (element) => {
        //we can get dom element here, what ever you want you can do
        console.log(element)
        element.focus()
    }
}
</script>

2.attach directive on html element.
<template>
    <input v-focus>
</template>
.....................................................................................
			 DOM Manipulation using Directives

<script setup>
const vHighlight = {

    mounted: (element) => {
        //
        element.addEventListener('mousemove', evt => {
             highLight('yellow')
        })
        element.addEventListener('mouseleave', evt => {
            highLight(null)
        })
        const highLight = color => {
            element.style.backgroundColor = color
        }
    }
}
</script>
<template>
    <h1 v-highlight>HighLight Me!</h1>
</template>
<style>

</style>
.....................................................................................
		    Component/Directive Hooks
.....................................................................................
Directive Hooks:
  Directive hooks are methods which are called in every life cycle of directive

created(element,binding,vnode,prevNode)

beforeMount () - called before the target element is inserted into dom

mounted() -> called before the parent component is updated

beforeUpdate()- called after the parent component and all of its childern have updated

update() -called after beforeUpdate

beforeUnmount() - before removing element

unmounted()  - when component is unmounted
.....................................................................................
			 Directives parameters,modifiers,args
.....................................................................................
binding object hold all information about directive


How to pass parameter to directive?

<input v-bind:value="msg">
                      |
		    Parameter				
  
import { createApp } from 'vue'
import App from './App.vue'

createApp(App)
    .provide('company', 'google')
    .directive('focus', (element, binding) => {
        console.log('directive => ', element)
        element.focus()
    })
    .directive('highlight', (element, binding) => {
      
        //set inital color:
        element.style.backgroundColor = binding.value
        element.addEventListener('mousemove', (evt) => {
            //element.style.backgroundColor = 'yellow'
            highLight('yellow')
        })
        //remove style
        element.addEventListener('mouseleave', (evt) => {
            // element.style.backgroundColor = null
            highLight(null)
        })
        const highLight = (color) => {
            element.style.backgroundColor = color
        }
    })
    .mount('#app')

.....
another eg:
<script setup>
import { ref } from 'vue'
const color = ref('green')
</script>
<template>
    <h1 v-highlight.value="color">HighLight</h1>
    <!-- directive:arg.modifier -->
    <h1 v-highlight:foo.bar="color">HighLight</h1>

    <p v-demo>this is demo directive -simple</p>
    <p v-demo:foo>this is demo directive-arg</p>
    <p v-demo:foo.bar>this is demo directive-modifier</p>
    <p v-demo:foo.bar="color">this is demo directive</p>
    <p v-demo:foo.bar="{ color: 'green', label: 'Greetings' }">this is demo 
    
    directive</p>
    <p v-demo:value="color">this is demo directive-arg</p>
    <p v-demo="color">this is demo directive-arg</p>

</template>
import { createApp } from 'vue'
import App from './App.vue'
import StatusBar from './components/StatusBar.vue'

// import './assets/main.css'

// createApp(App).mount('#app')
const app = createApp(App)
//global Component
app.component('StatusBar', StatusBar)
//global data 
app.provide('company', 'google')

//global directives
app.directive('highlight', (element, binding) => {
    //console.log('element', element)
    //console.log('binding', binding)

    //get parameters supplied as part of directive
    console.log(binding)
    console.log('value', binding.value)

    element.addEventListener('mousemove', (evt) => {
        //element.style.backgroundColor = 'yellow'
        highLight('pink')
    })
    //remove style
    element.addEventListener('mouseleave', (evt) => {
        // element.style.backgroundColor = null
        highLight(null)
    })
    const highLight = (color) => {
        element.style.backgroundColor = color
    }
    highLight(binding.value)

})
app.directive('demo', (element, binding) => {
    console.log('element => ', element)
    console.log('binding => ', binding)
})


app.mount('#app')

.....................................................................................

import { createApp } from 'vue'
import App from './App.vue'
import StatusBar from './components/global/StatusBar.vue'
// import './assets/main.css'
// console.log(App)
// const app = createApp(App)
// app.component('StatusBar', StatusBar)
// app.mount('#app')

createApp(App)
     //key-Component Name,value-Component Reference(Object)
     .component('StatusBar', StatusBar)
     .provide('company', 'IBM')
     .directive('highlight', (element, binding) => {
          //binding is reference of Binding object which can capture the parameters
          //passed as part of directive
          console.log(binding)
          if(binding.modifiers.bar){
               element.style.color = 'green'
          }
          element.style.backgroundColor = binding.value
          element.addEventListener('mousemove', (evt) => {
               //element.style.backgroundColor = 'yellow'
               highLight('yellow')
          })
          //remove style
          element.addEventListener('mouseleave', (evt) => {
               // element.style.backgroundColor = null
               highLight(null)
          })
          const highLight = (color) => {
               element.style.backgroundColor = color
          }
     })
     .mount('#app')

<script setup>
import {ref} from 'vue'
const color = ref('blue')
</script>
<template>
    <!-- sending parameters to directive -->
    <h1 v-highlight.value="color">Highlight</h1>
    <!-- Directive Modifer : args -->
    <h1 v-highlight:foo.bar="color">Highlight</h1>

</template>
<style>
</style>
			   Plugins
....................................................................................
What is plugin?

 Plugins are self contained code that usuallay add app-top level functionality to Vue.
Most of third party libs are integrated as plugin with vue echo system eg: Vue-router
Statement management libs like vuex,Pinia.

Plugins are distribtued as npm modules, in order to use plugins, we have to do two things

1.install plugin as npm moudle

 npm install vue-router@4

2.Integrate with Application object

const app =createApp(App)

//directives
app.directive('demo',{})
//components
app.components('component',{})

//plugins
app.use(myPlugin)
app.use(router)

app.mount("#app");
.....................................................................................
How to write Custom Plugins?

Steps 1:
src/plugins/myPlugin.js
//uppercase 
export const myPlugin = {
    install(app, options) {
        //application object referenced in the plugin as first parameter
        app.config.globalProperties.$uppercase = key => {
            return key.toUpperCase();
        }
    }
}

Step 2: Register the Plugin in application object.

import { createApp } from 'vue'
import App from './App.vue'
import { myPlugin } from './plugins/myplugin'

createApp(App)
    .use(myPlugin)
    .mount('#app')

Step 3: 
Use Plugin functionality inside app

<script setup>
</script>
<template>
  <h1>{{$uppercase('hello,how are you')}}</h1>
</template>
.....................................................................................
...................................................................................
		     	How to build SPA :Routing
....................................................................................

SPA is type of web application built for browsers, all navagations are done by javascript  , html only.

SPA is called client side routing.

SPA core features:

1.all navagation is controlled inside browser only
2.From the server we get only data via apis as json format
3.In spa, only we have one physical page called landing page /home page
4.Name of the landing page would be "index.html"
5.Rest of application page are called "virtual pages" which are created by js  dynamically we call "components"
6.navigation is controlled by javascript objects called "location and histroy objects"
7.Frameworks for routing is built on the top of these objects only.
8.in order to build routing we need "HTML 5" 


Routing can be implemented using plain js,html5,ajax,css3 itself, but in large scale we need framework, Vue supports official "vue router" which is supplied as "plugin"

How to start using router?

for existing application

1.npm install vue-router@4

2.Application configuration
  app.use(router)

For creating new application.

npm init vue@latest

Vue.js - The Progressive JavaScript Framework

√ Project name: ... vue-spa
√ Add TypeScript? ... No / Yes
√ Add JSX Support? ... No / Yes
√ Add Vue Router for Single Page Application development? ... No / Yes - Yes
√ Add Pinia for state management? ... No / Yes
√ Add Vitest for Unit Testing? ... No / Yes
√ Add Cypress for both Unit and End-to-End testing? ... No / Yes
√ Add ESLint for code quality? ... No / Yes

Scaffolding project in E:\session\IBM\2022\oct\vuejs-session\vue-spa...

Done. Now run:

  cd vue-spa
  npm install
  npm run dev

Web Application url pattern:

1.static url
 http://www.example.com/products.html / products.pdf
2.dynamic web url
 http://www.example.com/products.do /products.jsp | products.aspx | products.php
3.Web service url - REST Api
 http://www.example.com/api/products =>json
4.SPA Web url


SPA URL Patterns:
................
1.web url - looks like web service url
   http://www.example.com/hello /products
2.hash url pattern-  hash bang url pattern

http://www.example.com/index.html#hello | #products

................................................................................
			 Steps for building spa

folders structure
 src
   -components
	|
	Users
	Products
   -composables
   -plugins
   -directives
   -router
   -pages

Components:
  Going to hold all components which has state,props....
Pages:
  Going to hold components only but which is mapped against urls
  Page contains only basic page template not actual compoent logic.

Flow
 Link--->Page-->render components	 
  
composables:
 It holds all resuable statefull logics

directives
 It holds all custom directives
 
router:
 It holds router app configuration.

		 Steps for building spa

1.router configuration:
router/index.js

import Home from '../components/Home.vue'
import HelloWorld from '../components/HelloWorld.vue';
import { createRouter, createWebHistory } from 'vue-router'


//route configuration
const routes = [
    {
        path: '/',
        component: Home
    },
    {
        path: '/hello',
        component: HelloWorld
    }
]
//create router object
const router = createRouter({
    history: createWebHistory(import.meta.env.BASE_URL),
    routes
})

export default router;

2.main.js
import { createApp } from 'vue'
import App from './App.vue'
import router from './router'

createApp(App)
    .use(router)
    .mount('#app')

3.routing/index.js
import { createRouter, createWebHistory } from 'vue-router'
import HomeView from '../views/HomeView.vue'

const router = createRouter({
  history: createWebHistory(import.meta.env.BASE_URL),
  routes: [
    {
      path: '/',
      name: 'home',
      component: HomeView
    },
    {
      path: '/about',
      name: 'about',
      // route level code-splitting
      // this generates a separate chunk (About.[hash].js) for this route
      // which is lazy-loaded when the route is visited.
      component: () => import('../views/AboutView.vue')
    },
    {
      path: '/review',
      name: 'reivew',
      // route level code-splitting
      // this generates a separate chunk (About.[hash].js) for this route
      // which is lazy-loaded when the route is visited.
      component: () => import('../views/ReviewVue.vue')
    }
  ]
})

export default router


App.vue
<script setup>
import { RouterLink, RouterView } from 'vue-router'
// import HelloWorld from './components/HelloWorld.vue'
</script>

<template>
  <header>
    <h1>Vue App Routing</h1>
    <div>
      <!-- <HelloWorld msg="You did it!" /> -->
      <nav>
        <ul>
          <li>
            <RouterLink to="/">Home</RouterLink>
          </li>
          <li>
            <RouterLink to="/about">About</RouterLink>
          </li>
          <li>
            <RouterLink to="/review">Review</RouterLink>
          </li>
        </ul>
      </nav>
    </div>
  </header>

  <RouterView />
</template>

<style scoped>
h1 {
  text-align: center;
}
</style>

..................................................................................
			   Dynamic routing : Dynamic Urls
.................................................................................

/users/:id  
/users/1 

route configuration
  {
      path: '/users/:id',
      name: 'users',
      component: () => import('../views/UsersView.vue')
    }

UsersView.vue
<script setup>
</script>
<template>
    <h1>User details</h1>
</template>

http://localhost:5173/users/2

How to read route parameter?

Inside Template:
<script setup>

</script>
<template>
    <h1>User details</h1>
    {{$route.params}}
    {{$route.params.id}} details
</template>


Inside script:
import { useRoute } from 'vue-router';
const route = useRoute()
console.log(route.params.id)
....................................................................................
....................................................................................
			 Master Details 


Route Configuration:
   {
      path: '/users',
      name: 'users',
      component: () => import('../views/UsersView.vue')
    },
    {
      path: '/details/:id',
      name: 'details',
      component: () => import('../views/UsersDetailsView.vue')
    }

Components:
UserView.vue
<script setup>
import UserList from "../components/users/UserList.vue";
</script>
<template>
    <UserList></UserList>
</template>

UserList.vue
<script setup>
import { reactive } from 'vue';

const USERS = [
    { id: 12, name: 'Dr. Nice' },
    { id: 13, name: 'Bombasto' },
    { id: 14, name: 'Celeritas' },
    { id: 15, name: 'Magneta' },
    { id: 16, name: 'RubberMan' },
    { id: 17, name: 'Dynama' },
    { id: 18, name: 'Dr. IQ' },
    { id: 19, name: 'Magma' },
    { id: 20, name: 'Tornado' }
];
const users = reactive(USERS)
</script>
<template>
    <h1>User List</h1>
    <ul>
        <li v-for="user of users">
            <RouterLink :to="'/details/'+ user.id">
                <span>{{user.name}}</span>
            </RouterLink>
        </li>
    </ul>
</template>

UsersDetails.vue
<script setup>
</script>
<template>
    <h1>{{$route.params.id}}</h1>
</template>

Build master details:
 
Inside loop:
  <RouterLink :to="'/details/'+ user.id">
                <span>{{user.name}}</span>
  </RouterLink>
.....................................................................................
....................................................................................
			 Named Routes
....................................................................................

Without Named routes

const routes = [
 {
   path:'/details/:id',
   component:UserDetails
 }
]
  <RouterLink :to="'/details/'+ user.id">
                <span>{{user.name}}</span>
  </RouterLink>

Here we have to refer the whole path, instead we can simply using names

const routes = [
 {
   path:'/details/:id',
   name:'details',
   component:UserDetails
 }
]

    <RouterLink :to="{name:'details',params:{id:user.id} }">
                <span>{{user.name}}</span>
     </RouterLink>
eg:

rout config
  {
      path: '/details/:id',
      name: 'details',
      component: () => import('../views/UsersDetailsView.vue')
    }
<script setup>
import { reactive } from 'vue';

const USERS = [
    { id: 12, name: 'Dr. Nice' },
    { id: 13, name: 'Bombasto' },
    { id: 14, name: 'Celeritas' },
    { id: 15, name: 'Magneta' },
    { id: 16, name: 'RubberMan' },
    { id: 17, name: 'Dynama' },
    { id: 18, name: 'Dr. IQ' },
    { id: 19, name: 'Magma' },
    { id: 20, name: 'Tornado' }
];
const users = reactive(USERS)
</script>
<template>
    <h1>User List</h1>
    <ul>
        <li v-for="user of users">
            <!-- <RouterLink :to="'/details/'+ user.id">
                <span>{{user.name}}</span>
            </RouterLink> -->
            <!-- With Named Routing -->
            <RouterLink :to="{name:'details',params:{id:user.id} }">
                <span>{{user.name}}</span>
            </RouterLink>
        </li>
    </ul>
</template>
....................................................................................
				Nested Routers
.....................................................................................
Building Sub menus;
...................

Movie

 Sci
 Adv
 drama

eg:

Route Configuration
{
      path: '/movies',
      name: 'movies',
      component: () => import('../views/MoviesView.vue'),
      children: [
        {
          path: 'action',
          component: () => import('../views/ActionView.vue'),
        },
        {
          path: 'drama',
          component: () => import('../views/DramaView.vue'),
        },
        {
          path: 'horror',
          component: () => import('../views/HorrorView.vue'),
        }
      ]
    }

App.vue
<script setup>
import { RouterLink, RouterView } from 'vue-router'
// import HelloWorld from './components/HelloWorld.vue'
</script>

<template>
  <header>
    <h1>Vue App Routing</h1>
    <div>
      <!-- <HelloWorld msg="You did it!" /> -->
      <nav>
        <ul>
          <li>
            <RouterLink to="/">Home</RouterLink>
          </li>
          <li>
            <RouterLink to="/about">About</RouterLink>
          </li>
          <li>
            <RouterLink to="/review">Review</RouterLink>
          </li>
          <li>
            <RouterLink to="/users">Users</RouterLink>
          </li>
          <li>
            <RouterLink to="/movies">Movies</RouterLink>
          </li>
        </ul>
      </nav>
    </div>
  </header>

  <RouterView />
</template>

<style scoped>
h1 {
  text-align: center;
}
</style>

MoviesReview.vue
<script setup>
</script>
<template>
    <h1>Movie View</h1>
    <ul>
        <li>
            <RouterLink to="/movies/action">
                <span>Action</span>
            </RouterLink>
        </li>
        <li>
            <RouterLink to="/movies/drama">
                <span>Drama</span>
            </RouterLink>
        </li>
        <li>
            <RouterLink to="/movies/horror">
                <span>Horror</span>
            </RouterLink>
        </li>
    </ul>
    <RouterView />
</template>


ActionView.vue
<script setup>
</script>
<template>
    <h1>Action</h1>
</template>
.....................................................................................				 Redirections

  {
      path: '/',
      redirect: { name: 'home' }
    },
    {
      path: '/home',
      name: 'home',
      component: HomeView
    },

eg:
import { createRouter, createWebHistory } from 'vue-router'
import HomeView from '../views/HomeView.vue'
import ReviewView from '../views/ReviewView.vue'

const router = createRouter({
  history: createWebHistory(import.meta.env.BASE_URL),
  routes: [
    {
      path: '/',
      //component: HomeView
      redirect: { name: 'home' }
    },
    {
      path: '/home',
      name: 'home',
      component: HomeView
    },
    {
      path: '/review',
      name: 'review',
      component: ReviewView
    },

    {
      path: '/users',
      name: 'users',
      component: () => import('../views/UsersView.vue')
    },
    {
      path: '/details/:id',
      name: 'details',
      component: () => import('../views/UsersDetailsView.vue')
    },
    {
      path: '/movies',
      name: 'movies',
      component: () => import('../views/MoviesView.vue'),
      children: [
        {
          path: '',
          redirect: { name: 'action' }
        },
        {
          path: 'action',
          name: 'action',
          component: () => import('../views/ActionView.vue'),
        },
        {
          path: 'drama',
          component: () => import('../views/DramaView.vue'),
        },
        {
          path: 'horror',
          component: () => import('../views/HorrorView.vue'),
        }
      ]
    },
    {
      path: '/about',
      name: 'about',
      // route level code-splitting
      // this generates a separate chunk (About.[hash].js) for this route
      // which is lazy-loaded when the route is visited.
      component: () => import('../views/AboutView.vue')
    }
  ]
})

export default router
<script setup>
import { RouterLink, RouterView } from 'vue-router'
</script>
<template>
    <h1>Movie View</h1>
    <ul>
        <li>
            <RouterLink to="/movies/action">
                <span>Action</span>
            </RouterLink>
        </li>
        <li>
            <RouterLink to="/movies/drama">
                <span>Drama</span>
            </RouterLink>
        </li>
        <li>
            <RouterLink to="/movies/horror">
                <span>Horror</span>
            </RouterLink>
        </li>
    </ul>
    <RouterView />
</template>

/////////////////////////////////////////////////////////////////////////////////
..................................................................................
				Programmetic Navigation

Using Router Object we can navigate to Views


const router = useRouter()

Syntax:
string:
  router.push('/users')
 
object Notation
 router.push({path:'/user'})
 
passing params 
 router.push({path:'/user',params:{userid:1}}

Query Strings:
  /user?type=admin
 router.push({path:'/user',query:{type:'admin'})



<script setup>
import { useRouter } from 'vue-router';

const router = useRouter()
const gotoReview = () => {
    router.push('/review')
}
</script>
<template>
    <h1>Movie View</h1>
    <ul>
        <li>
            <RouterLink to="/movies/action">
                <span>Action</span>
            </RouterLink>
        </li>
        <li>
            <RouterLink to="/movies/drama">
                <span>Drama</span>
            </RouterLink>
        </li>
        <li>
            <RouterLink to="/movies/horror">
                <span>Horror</span>
            </RouterLink>
        </li>
    </ul>
    <RouterView />
    <button @click="gotoReview">Review</button>
</template>
.....................................................................................	
/////////////////////////////////////////////////////////////////////////////////
			Routing and Props

const User = {
  // make sure to add a prop named exactly like the route param
  props: ['id'],
  template: '<div>User {{ id }}</div>'
}
const routes = [{ path: '/user/:id', component: User, props: true }]
..................................................................................
			Building CURD APP
...................................................................................

Menu - 1 - Home Page
-----------------------------------------------------------------------------------
  Products        Add New Product
....................................................................................

As soon as you land the Home page , you have display Products Page
-----------------------------------------------------------------------------------
  Products        Add New Product
....................................................................................
   Search Text Box  : Search Button

  Product 1 
  Product 2
  Product 3
  Product 4
  Product 5

The Product details must be fetched from the api- Use composable
You have to create ProductList Component,Search Compoent
When ever you type product name , it should filter and show only filtered result.

-----------------------------------------------------------------------------------
  Products        Add New Product
....................................................................................
   Search Text Box  : Search Button

  Product 1 
  Product 2
  Product 3
  Product 4
  Product 5

When you select a product, you should display the product details in the next page
Product details page.

Product 1 details
Name:....
Description:.....
status: available or outof stock
Edit Button

When you edit , it should allow to load description,status, into separate edit page..

after edition, you must have save and return to the product list page

Optional Feature:
 Delete 

Product 1 details
Name:....
Description:.....
status: available or outof stock
Edit Button  Delete Button

When you click delete button,it should ask do you want to delete, if you yes, delete the product and navigate to list

 Add New Product

It should display product add page, get all details and save send to api.


How to setup api?

https://github.com/typicode/json-server	














